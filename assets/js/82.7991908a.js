(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{496:function(e,t,i){"use strict";i.r(t);var r=i(21),n=Object(r.a)({},(function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[i("p",[e._v("SpringSecurity 采用的是责任链的设计模式，它有一条很长的过滤器链。现在对这条过滤器链的各个进行说明:")]),e._v(" "),i("ol",[i("li",[i("p",[e._v("WebAsyncManagerIntegrationFilter：将 Security 上下文与 Spring Web 中用于处理异步请求映射的 WebAsyncManager 进行集成。")])]),e._v(" "),i("li",[i("p",[e._v("SecurityContextPersistenceFilter：在每次请求处理之前将该请求相关的安全上下文信息加载到 SecurityContextHolder 中，然后在该次请求处理完成之后，将 SecurityContextHolder 中关于这次请求的信息存储到一个“仓储”中，然后将 SecurityContextHolder 中的信息清除，例如在Session中维护一个用户的安全信息就是这个过滤器处理的。")])]),e._v(" "),i("li",[i("p",[e._v("HeaderWriterFilter：用于将头信息加入响应中。")])]),e._v(" "),i("li",[i("p",[e._v("CsrfFilter：用于处理跨站请求伪造。")])]),e._v(" "),i("li",[i("p",[e._v("LogoutFilter：用于处理退出登录。")])]),e._v(" "),i("li",[i("p",[e._v("UsernamePasswordAuthenticationFilter：用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自 /login 的请求。从表单中获取用户名和密码时，默认使用的表单 name 值为 username 和 password，这两个值可以通过设置这个过滤器的usernameParameter 和 passwordParameter 两个参数的值进行修改。")])]),e._v(" "),i("li",[i("p",[e._v("DefaultLoginPageGeneratingFilter：如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。")])]),e._v(" "),i("li",[i("p",[e._v("BasicAuthenticationFilter：检测和处理 http basic 认证。")])]),e._v(" "),i("li",[i("p",[e._v("RequestCacheAwareFilter：用来处理请求的缓存。")])]),e._v(" "),i("li",[i("p",[e._v("SecurityContextHolderAwareRequestFilter：主要是包装请求对象request。")])]),e._v(" "),i("li",[i("p",[e._v("AnonymousAuthenticationFilter：检测 SecurityContextHolder 中是否存在 Authentication 对象，如果不存在为其提供一个匿名 Authentication。")])]),e._v(" "),i("li",[i("p",[e._v("SessionManagementFilter：管理 session 的过滤器")])]),e._v(" "),i("li",[i("p",[e._v("ExceptionTranslationFilter：处理 AccessDeniedException 和 AuthenticationException 异常。")])]),e._v(" "),i("li",[i("p",[e._v("FilterSecurityInterceptor：可以看做过滤器链的出口。")])]),e._v(" "),i("li",[i("p",[e._v("RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时, 从 cookie 里找出用户的信息, 如果 Spring Security 能够识别出用户提供的remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统，该过滤器默认不开启。")])])]),e._v(" "),i("p",[e._v("先来看下面一个 Spring Security 执行流程图，只要把 SpringSecurity 的执行过程弄明白了，这个框架就会变得很简单")]),e._v(" "),i("p",[i("img",{attrs:{src:"https://img.xiaoyou66.com/2021/04/07/b8a217feaa8ab.png",alt:"image.png"}})]),e._v(" "),i("p",[e._v("一个简单的流程")]),e._v(" "),i("ol",[i("li",[e._v("客户端发起一个请求，进入 Security 过滤器链。")]),e._v(" "),i("li",[e._v("当到 LogoutFilter 的时候判断是否是登出路径，如果是登出路径则到 logoutHandler ，如果登出成功则到 logoutSuccessHandler 登出成功处理，如果登出失败则由 ExceptionTranslationFilter ；如果不是登出路径则直接进入下一个过滤器。")]),e._v(" "),i("li",[e._v("当到 UsernamePasswordAuthenticationFilter 的时候判断是否为登录路径，如果是，则进入该过滤器进行登录操作，如果登录失败则到 AuthenticationFailureHandler 登录失败处理器处理，如果登录成功则到 AuthenticationSuccessHandler 登录成功处理器处理，如果不是登录请求则不进入该过滤器。")]),e._v(" "),i("li",[e._v("当到 FilterSecurityInterceptor 的时候会拿到 uri ，根据 uri 去找对应的鉴权管理器，鉴权管理器做鉴权工作，鉴权成功则到 Controller 层否则到 AccessDeniedHandler 鉴权失败处理器处理。")])]),e._v(" "),i("h3",{attrs:{id:"spring-security扩展"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#spring-security扩展"}},[e._v("#")]),e._v(" spring security扩展")]),e._v(" "),i("p",[e._v("Security 可扩展的有")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("鉴权失败处理器")]),e._v(" "),i("p",[e._v("Security 鉴权失败默认跳转登录页面，我们可以实现 AccessDeniedHandler 接口，重写 handle() 方法来自定义处理逻辑；然后参考配置类说明将处理器加入到配置当中。")])]),e._v(" "),i("li",[i("p",[e._v("验证器")]),e._v(" "),i("p",[e._v("实现 AuthenticationProvider 接口来实现自己验证逻辑。需要注意的是在这个类里面就算你抛出异常，也不会中断验证流程，而是算你验证失败，我们由流程图知道，只要有一个验证器验证成功，就算验证成功，所以你需要留意这一点。")])]),e._v(" "),i("li",[i("p",[e._v("登录成功处理器")]),e._v(" "),i("p",[e._v('在 Security 中验证成功默认跳转到上一次请求页面或者路径为 "/" 的页面，我们同样可以自定义：继承 SimpleUrlAuthenticationSuccessHandler 这个类或者实现 AuthenticationSuccessHandler 接口。我这里建议采用继承的方式,SimpleUrlAuthenticationSuccessHandler 是默认的处理器，采用继承可以契合里氏替换原则，提高代码的复用性和避免不必要的错误。')])]),e._v(" "),i("li",[i("p",[e._v("投票器")]),e._v(" "),i("p",[e._v("投票器可继承 WebExpressionVoter 或者实现 AccessDecisionVoter接口；WebExpressionVoter 是 Security 默认的投票器；我这里同样建议采用继承的方式；添加到配置的方式参考 上文；")]),e._v(" "),i("p",[e._v("注意：投票器 vote 方法返回一个int值；-1代表反对，0代表弃权，1代表赞成；投票管理器收集投票结果，如果最终结果大于等于0则放行该请求。")])]),e._v(" "),i("li",[i("p",[e._v("自定义token处理过滤器")]),e._v(" "),i("p",[e._v("自定义 token 处理器继承自 OncePerRequestFilter 或者 GenericFilterBean 或者 Filter 都可以，在这个处理器里面需要完成的逻辑是：获取请求里的 token，验证 token 是否合法然后填充 SecurityContextHolder ，虽然说过滤器只要添加在投票器之前就可以，但我这里还是建议添加在 http.addFilterAfter(new MyFittler(), LogoutFilter.class);")])]),e._v(" "),i("li",[i("p",[e._v("登出成功处理器")]),e._v(" "),i("p",[e._v("实现LogoutSuccessHandler接口，添加到配置的方式参考上文。")])]),e._v(" "),i("li",[i("p",[e._v("登录失败处理器")]),e._v(" "),i("p",[e._v("登录失败默认跳转到登录页，我们同样可以自定义。继承 SimpleUrlAuthenticationFailureHandler 或者实现 AuthenticationFailureHandler，建议采用继承。")])]),e._v(" "),i("li",[i("p",[e._v("自定义 UsernamePasswordAuthenticationFilter")]),e._v(" "),i("p",[e._v("我们自定义UsernamePasswordAuthenticationFilter可以极大提高我们 Security的灵活性（比如添加验证验证码是否正确的功能）。")]),e._v(" "),i("p",[e._v("我们直接继承 UsernamePasswordAuthenticationFilter ，然后在配置类中初始化这个过滤器，给这个过滤器添加登录失败处理器，登录成功处理器，登录管理器，登录请求 url 。")])])]),e._v(" "),i("p",[e._v("参考：")]),e._v(" "),i("ul",[i("li",[i("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/72305502",target:"_blank",rel:"noopener noreferrer"}},[e._v("深入了解Spring Security的实现原理 - 知乎 (zhihu.com)"),i("OutboundLink")],1)]),e._v(" "),i("li",[i("a",{attrs:{href:"https://blog.csdn.net/u012702547/article/details/89629415",target:"_blank",rel:"noopener noreferrer"}},[e._v("Spring Security 工作原理概览_江南一点雨的专栏-CSDN博客"),i("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=n.exports}}]);