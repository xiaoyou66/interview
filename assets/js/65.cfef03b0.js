(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{479:function(e,a,c){"use strict";c.r(a);var t=c(21),r=Object(t.a)({},(function(){var e=this,a=e.$createElement,c=e._self._c||a;return c("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[c("h2",{attrs:{id:"cpu-cache结构和缓存一致性-mesi协议"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#cpu-cache结构和缓存一致性-mesi协议"}},[e._v("#")]),e._v(" CPU cache结构和缓存一致性（MESI协议）")]),e._v(" "),c("p",[e._v("在多核CPU中，内存中的数据会在多个核心中存在数据副本，某一个核心发生修改操作，就产生了数据不一致的问题。而一致性协议正是用于保证多个CPU cache之间缓存共享数据的一致。至于MESI，则是缓存一致性协议中的一个，到底怎么实现，还是得看具体的处理器指令集")]),e._v(" "),c("h3",{attrs:{id:"几个概念"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#几个概念"}},[e._v("#")]),e._v(" 几个概念")]),e._v(" "),c("h4",{attrs:{id:"cache写操作"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#cache写操作"}},[e._v("#")]),e._v(" cache写操作")]),e._v(" "),c("p",[e._v("A. write through（写通）：每次CPU修改了cache中的内容，立即更新到内存，也就意味着每次CPU写共享数据，都会导致总线事务，因此这种方式常常会引起总线事务的竞争，高一致性，但是效率非常低；")]),e._v(" "),c("p",[e._v("B. write back（写回）：每次CPU修改了cache中的数据，不会立即更新到内存，而是等到cache line在某一个必须或合适的时机才会更新到内存中；")]),e._v(" "),c("p",[e._v("无论是写通还是写回，在多核环境下都需要处理缓存cache一致性问题。为了保证缓存一致性，处理器又提供了写失效（write invalidate）和写更新（write update）两个操作来保证cache一致性。")]),e._v(" "),c("p",[e._v("A. 写失效：当一个CPU修改了数据，如果其他CPU有该数据，则通知其为无效；")]),e._v(" "),c("p",[e._v("B. 写更新：当一个CPU修改了数据，如果其他CPU有该数据，则通知其跟新数据；")]),e._v(" "),c("p",[e._v("写更新会导致大量的更新操作，因此在MESI协议中，采取的是写失效（即MESI中的I：ivalid，如果采用的是写更新，那么就不是MESI协议了，而是MESU协议）。")]),e._v(" "),c("p",[e._v("所以，现在常见的多核CPU写方式：写命中时，核内write back，核间write invalid + cache coherency protocol；写miss，先write allocated，再走前述的写命中流程。（write allocated和no-write allocated见评论区）")]),e._v(" "),c("h4",{attrs:{id:"cache-line"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#cache-line"}},[e._v("#")]),e._v(" cache line")]),e._v(" "),c("p",[c("img",{attrs:{src:"https://img.xiaoyou66.com/2021/03/30/d4b191efbc4e1.png",alt:"image.png"}})]),e._v(" "),c("p",[e._v("cache line是cache与内存数据交换的最小单位，根据操作系统一般是32byte或64byte。在MESI协议中，状态可以是M、E、S、I，地址则是cache line中映射的内存地址，数据则是从内存中读取的数据。")]),e._v(" "),c("p",[e._v("工作方式：当CPU从cache中读取数据的时候，会比较地址是否相同，如果相同则检查cache line的状态，再决定该数据是否有效，无效则从主存中获取数据，或者根据一致性协议发生一次cache-to--chache的数据推送")]),e._v(" "),c("p",[e._v("工作效率：当CPU能够从cache中拿到有效数据的时候，消耗几个CPU cycle，如果发生cache miss，则会消耗几十上百个CPU cycle")]),e._v(" "),c("p",[c("img",{attrs:{src:"https://img.xiaoyou66.com/2021/03/30/3601c795aceaf.png",alt:"image.png"}})]),e._v(" "),c("h4",{attrs:{id:"cache-line的几种状态"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#cache-line的几种状态"}},[e._v("#")]),e._v(" cache line的几种状态")]),e._v(" "),c("p",[e._v("MESI协议将cache line的状态分成modify、exclusive、shared、invalid，分别是修改、独占、共享和失效。")]),e._v(" "),c("p",[c("strong",[e._v("modify")]),e._v("：当前CPU cache拥有最新数据（最新的cache line），其他CPU拥有失效数据（cache line的状态是invalid），虽然当前CPU中的数据和主存是不一致的，但是以当前CPU的数据为准")]),e._v(" "),c("p",[c("strong",[e._v("exclusive")]),e._v("：只有当前CPU中有数据，其他CPU中没有改数据，当前CPU的数据和主存中的数据是一致的")]),e._v(" "),c("p",[e._v("shared：当前CPU和其他CPU中都有共同数据，并且和主存中的数据一致")]),e._v(" "),c("p",[c("strong",[e._v("invalid")]),e._v("：当前CPU中的数据失效，数据应该从主存中获取，其他CPU中可能有数据也可能无数据，当前CPU中的数据和主存被认为是不一致的")]),e._v(" "),c("p",[e._v("对于invalid而言，在MESI协议中采取的是写失效（write invalidate）")]),e._v(" "),c("h3",{attrs:{id:"cache的操作"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#cache的操作"}},[e._v("#")]),e._v(" cache的操作")]),e._v(" "),c("p",[e._v("MESI协议中，每个cache的控制器不仅知道自己的操作（local read和local write），每个核心的缓存控制器通过监听也知道其他CPU中cache的操作（remote read和remote write），今儿再确定自己cache中共享数据的状态是否需要调整。")]),e._v(" "),c("ul",[c("li",[e._v("local read（LR）：读本地cache中的数据；")]),e._v(" "),c("li",[e._v("local write（LW）：将数据写到本地cache；")]),e._v(" "),c("li",[e._v("remote read（RR）：其他核心发生read；")]),e._v(" "),c("li",[e._v("remote write（RW）：其他核心发生write；")])]),e._v(" "),c("p",[e._v("参考")]),e._v(" "),c("p",[c("a",{attrs:{href:"https://blog.csdn.net/reliveIT/article/details/50450136",target:"_blank",rel:"noopener noreferrer"}},[e._v("【并发编程】CPU cache结构和缓存一致性（MESI协议）_厚积薄发者，轻舟万重山-CSDN博客"),c("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=r.exports}}]);