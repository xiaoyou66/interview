(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{498:function(t,_,r){"use strict";r.r(_);var a=r(21),v=Object(a.a)({},(function(){var t=this,_=t.$createElement,r=t._self._c||_;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"spring事务传播"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#spring事务传播"}},[t._v("#")]),t._v(" spring事务传播")]),t._v(" "),r("p",[t._v("为什么要有事务传播呢？默认情况下，spring是使用aop来实现事务的，我们只需要在方法上面加上 "),r("code",[t._v("@Transactional")]),t._v(" 注解就可以了，但是这个时候会有几个问题比如 serviceA 方法调用了 serviceB 方法，但两个方法都有事务，这个时候如果 serviceB 方法异常，是让 serviceB 方法提交，还是两个一起回滚？")]),t._v(" "),r("p",[t._v("这里我们就要用到事务传播了，spring提供了7中事务传播行为（使用"),r("code",[t._v("@Transaction(Propagation=XXX)")]),t._v("设置决定）")]),t._v(" "),r("h3",{attrs:{id:"propagation-required-默认"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#propagation-required-默认"}},[t._v("#")]),t._v(" PROPAGATION_REQUIRED (默认)")]),t._v(" "),r("ul",[r("li",[t._v("支持当前事务，如果当前没有事务，则新建事务")]),t._v(" "),r("li",[t._v("如果当前存在事务，则加入当前事务，合并成一个事务")])]),t._v(" "),r("h3",{attrs:{id:"requires-new"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#requires-new"}},[t._v("#")]),t._v(" REQUIRES_NEW")]),t._v(" "),r("ul",[r("li",[t._v("新建事务，如果当前存在事务，则把当前事务挂起")]),t._v(" "),r("li",[t._v("这个方法会独立提交事务，不受调用者的事务影响，父级异常，它也是正常提交")])]),t._v(" "),r("h3",{attrs:{id:"nested"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#nested"}},[t._v("#")]),t._v(" NESTED")]),t._v(" "),r("ul",[r("li",[t._v("如果当前存在事务，它将会成为父级事务的一个子事务，方法结束后并没有提交，只有等父事务结束才提交")]),t._v(" "),r("li",[t._v("如果当前没有事务，则新建事务")]),t._v(" "),r("li",[t._v("如果它异常，父级可以捕获它的异常而不进行回滚，正常提交")]),t._v(" "),r("li",[t._v("但如果父级异常，它必然回滚，这就是和 "),r("code",[t._v("REQUIRES_NEW")]),t._v(" 的区别")])]),t._v(" "),r("h3",{attrs:{id:"supports"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#supports"}},[t._v("#")]),t._v(" SUPPORTS")]),t._v(" "),r("ul",[r("li",[t._v("如果当前存在事务，则加入事务")]),t._v(" "),r("li",[t._v("如果当前不存在事务，则以非事务方式运行，这个和不写没区别")])]),t._v(" "),r("h3",{attrs:{id:"not-supported"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#not-supported"}},[t._v("#")]),t._v(" NOT_SUPPORTED")]),t._v(" "),r("ul",[r("li",[t._v("以非事务方式运行")]),t._v(" "),r("li",[t._v("如果当前存在事务，则把当前事务挂起")])]),t._v(" "),r("h3",{attrs:{id:"mandatory"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mandatory"}},[t._v("#")]),t._v(" MANDATORY")]),t._v(" "),r("ul",[r("li",[t._v("如果当前存在事务，则运行在当前事务中")]),t._v(" "),r("li",[t._v("如果当前无事务，则抛出异常，也即父级方法必须有事务")])]),t._v(" "),r("h3",{attrs:{id:"never"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#never"}},[t._v("#")]),t._v(" NEVER")]),t._v(" "),r("ul",[r("li",[t._v("以非事务方式运行，如果当前存在事务，则抛出异常，即父级方法必须无事务")])]),t._v(" "),r("p",[t._v("一般用得比较多的是 "),r("code",[t._v("PROPAGATION_REQUIRED")]),t._v("， "),r("code",[t._v("REQUIRES_NEW")]),t._v("；")]),t._v(" "),r("p",[r("code",[t._v("REQUIRES_NEW")]),t._v(" 一般用在子方法需要单独事务")]),t._v(" "),r("p",[t._v("还有spring本身不提供事务功能，事务功能是数据库提供的")]),t._v(" "),r("blockquote",[r("p",[t._v("参考")])]),t._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[r("a",{attrs:{href:"https://segmentfault.com/a/1190000013341344",target:"_blank",rel:"noopener noreferrer"}},[t._v("Spring事务传播行为详解 - SegmentFault 思否"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://segmentfault.com/a/1190000020386113",target:"_blank",rel:"noopener noreferrer"}},[t._v("spring 事务的传播机制看这篇就够了 - SegmentFault 思否"),r("OutboundLink")],1)])]),t._v(" "),r("h2",{attrs:{id:"事务隔离的五种级别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#事务隔离的五种级别"}},[t._v("#")]),t._v(" 事务隔离的五种级别")]),t._v(" "),r("p",[r("strong",[t._v("TransactionDefinition 接口中定义了五个表示隔离级别的常量：")])]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("TransactionDefinition.ISOLATION_DEFAULT:")]),t._v(" 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.")]),t._v(" "),r("li",[r("strong",[t._v("TransactionDefinition.ISOLATION_READ_UNCOMMITTED:")]),t._v(" 最低的隔离级别，允许读取尚未提交的数据变更，"),r("strong",[t._v("可能会导致脏读、幻读或不可重复读")])]),t._v(" "),r("li",[r("strong",[t._v("TransactionDefinition.ISOLATION_READ_COMMITTED:")]),t._v(" 允许读取并发事务已经提交的数据，"),r("strong",[t._v("可以阻止脏读，但是幻读或不可重复读仍有可能发生")])]),t._v(" "),r("li",[r("strong",[t._v("TransactionDefinition.ISOLATION_REPEATABLE_READ:")]),t._v(" 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，"),r("strong",[t._v("可以阻止脏读和不可重复读，但幻读仍有可能发生。")])]),t._v(" "),r("li",[r("strong",[t._v("TransactionDefinition.ISOLATION_SERIALIZABLE:")]),t._v(" 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，"),r("strong",[t._v("该级别可以防止脏读、不可重复读以及幻读")]),t._v("。但是这将严重影响程序的性能。通常情况下也不会用到该级别。")])]),t._v(" "),r("h2",{attrs:{id:"事务失效的原因"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#事务失效的原因"}},[t._v("#")]),t._v(" 事务失效的原因")]),t._v(" "),r("p",[t._v("主要是这八点：")]),t._v(" "),r("ol",[r("li",[t._v("数据库引擎是否支持事务(比如MyISAM就不支持事务）")]),t._v(" "),r("li",[t._v("注解所在的类是否被加载成Bean")]),t._v(" "),r("li",[t._v("注解所在的方法是否为public所修饰")]),t._v(" "),r("li",[t._v("是否发生了自调用机制——同一个类之中的方法相互调用")]),t._v(" "),r("li",[t._v("所用的数据源是否加载了事务管理器")]),t._v(" "),r("li",[r("code",[t._v("@Transactional")]),t._v("的扩展配置propagation是否正确（七种传播行为）")]),t._v(" "),r("li",[t._v("异常被吃掉了——自己try自己catch")]),t._v(" "),r("li",[t._v("异常抛出错误——抛的不是RuntimeException")])]),t._v(" "),r("p",[r("img",{attrs:{src:"https://img.xiaoyou66.com/2021/04/09/6557a8de658ed.png",alt:"image-20210409204919647"}})])])}),[],!1,null,null,null);_.default=v.exports}}]);