(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{455:function(t,e,v){"use strict";v.r(e);var r=v(21),i=Object(r.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[t._v("说到这个结构，就不得不提一下安卓的几大结构吧主要包括 MVC、MVP、MVVM 这三大结构")]),t._v(" "),v("h2",{attrs:{id:"mvc结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mvc结构"}},[t._v("#")]),t._v(" MVC结构")]),t._v(" "),v("blockquote",[v("p",[v("strong",[t._v("Model")]),t._v(" ：实体模型、数据的获取、存储等等")]),t._v(" "),v("p",[v("strong",[t._v("View")]),t._v(" ：Activity、fragment、view、adapter、xml等等")]),t._v(" "),v("p",[v("strong",[t._v("Controller")]),t._v(" ：为View层处理数据，业务等等")])]),t._v(" "),v("p",[t._v("Android本身还是符合MVC架构的。不过由于作为纯View的xml功能太弱，以及controller能提供给开发者的作用较小，还不如在Activity页面直接进行处理，但这么做却造成了代码大爆炸。一个页面逻辑复杂的页面动辄上千行，注释没写好的话还十分不好维护，而且难以进行单元测试，所以这更像是一个Model-View的架构，不适用于打造稳定的Android项目。")]),t._v(" "),v("h2",{attrs:{id:"mvp结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mvp结构"}},[t._v("#")]),t._v(" MVP结构")]),t._v(" "),v("blockquote",[v("p",[v("strong",[t._v("Model")]),t._v(" 实体模型、数据的获取、存储等等")]),t._v(" "),v("p",[v("strong",[t._v("View")]),t._v(" Activity、fragment、view、adapter、xml等等")]),t._v(" "),v("p",[v("strong",[t._v("Presenter")]),t._v(" 负责完成View与Model间的交互和业务逻辑，以回调返回结果。")])]),t._v(" "),v("p",[t._v("前面说，Activity充当了View和Controller的作用， 造成了代码爆炸。而MVP架构很好的处理了这个问题。其核心理念是通过一个抽象的View接口（不是真正的View层）将Presenter与真正的View层进行解耦。Persenter持有该View接口，对该接口进行操作，而不是直接操作View层。这样就可以把视图操作和业务逻辑解耦，从而让Activity成为真正的View层。")]),t._v(" "),v("p",[t._v("这也是现今比较流行的架构，可是弊端也是有的。如果业务复杂了，也可能导致P层太臃肿，而且V和P层有一定耦合度，如果UI有什么地方需要更改，那么P层不只改一个地方那么简单，还需要改View的接口及其实现，牵一发动全身，运用MVP的同行都对此怨声载道。")]),t._v(" "),v("h2",{attrs:{id:"mvvm"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mvvm"}},[t._v("#")]),t._v(" MVVM")]),t._v(" "),v("p",[t._v("其实只有三层。。。我还以为是四层")]),t._v(" "),v("blockquote",[v("p",[t._v("Model：实体模型、数据的获取、存储等等")]),t._v(" "),v("p",[t._v("View：Activity、fragment、view、adapter、xml等等")]),t._v(" "),v("p",[t._v("ViewModel：负责完成View与Model间的交互和业务逻辑，基于DataBinding改变UI")])]),t._v(" "),v("p",[t._v("MVVM的目标和思想与MVP类似，但它没有MVP那令人厌烦的各种回调，利用DataBinding就可以更新UI和状态，达到理想的效果。")]),t._v(" "),v("p",[v("strong",[t._v("数据驱动UI")]),t._v(" 在使用MVC或MVP开发时，我们如果要更新UI，首先需要找到这个view的引用，然后赋予值，才能进行更新。在MVVM中，这就不需要了。MVVM是通过数据驱动UI的，这些都是自动完成。数据的重要性在MVVM架构中得到提高，成为主导因素。在这种架构模式中，开发者重点关注的是怎样处理数据，保证数据的正确性。")]),t._v(" "),v("p",[t._v("一般情况下，我们的项目架构如下")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://img.xiaoyou66.com/2021/04/22/80140a9e24bcf.png",alt:"image.png"}})]),t._v(" "),v("p",[t._v("参考："),v("a",{attrs:{href:"https://medium.com/@ditclear/%E4%BD%BF%E7%94%A8kotlin%E6%9E%84%E5%BB%BA%E6%9B%B4%E9%80%82%E5%90%88android%E7%9A%84mvvm%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-13dee86ad202",target:"_blank",rel:"noopener noreferrer"}},[t._v("使用Kotlin构建更适合Android的MVVM应用程序. 概述 | by ditclear | Medium"),v("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=i.exports}}]);