(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{466:function(_,v,t){"use strict";t.r(v);var r=t(21),o=Object(r.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("p",[_._v("包括 RDB 和 AOF 两种机制，下面分别进行说明")]),_._v(" "),t("h2",{attrs:{id:"rdb"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rdb"}},[_._v("#")]),_._v(" RDB")]),_._v(" "),t("p",[_._v("RDB 持久化机制，是对 Redis 中的数据执行周期性的持久化。更适合做冷备。")]),_._v(" "),t("p",[t("strong",[_._v("优点：")])]),_._v(" "),t("ol",[t("li",[_._v("压缩后的二进制文，适用于备份、全量复制，用于灾难恢复加载RDB恢复数据远快于AOF方式，适合大规模的数据恢复。")]),_._v(" "),t("li",[_._v("如果业务对数据完整性和一致性要求不高，RDB是很好的选择。数据恢复比AOF快。")])]),_._v(" "),t("p",[t("strong",[_._v("缺点：")])]),_._v(" "),t("ol",[t("li",[_._v("RDB是"),t("strong",[_._v("周期间隔性的快照文件")]),_._v("，数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机了。")]),_._v(" "),t("li",[_._v("备份时占用内存，因为Redis 在备份时会独立fork一个"),t("strong",[_._v("子进程")]),_._v("，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件。所以要考虑到大概两倍的数据膨胀性。")])]),_._v(" "),t("h3",{attrs:{id:"两种触发方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#两种触发方式"}},[_._v("#")]),_._v(" 两种触发方式")]),_._v(" "),t("ol",[t("li",[t("code",[_._v("SAVE")]),_._v(" 直接调用 rdbSave ，"),t("code",[_._v("阻塞")]),_._v(" Redis 主进程，导致无法提供服务。")]),_._v(" "),t("li",[t("code",[_._v("BGSAVE")]),_._v(" 则 fork 出一个子进程，子进程负责调用 rdbSave ，在保存完成后向主进程发送信号告知完成。在BGSAVE 执行期间"),t("strong",[_._v("仍可以继续处理客户端的请求")]),_._v("。")])]),_._v(" "),t("h3",{attrs:{id:"cow机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cow机制"}},[_._v("#")]),_._v(" COW机制")]),_._v(" "),t("p",[_._v("目的是为了解决RDB后台备份时，保证快照是精准的")]),_._v(" "),t("p",[_._v("全称Copy On Write，备份的是开始那个时刻内存中的数据，只复制被修改内存页数据，不是全部内存数据。")]),_._v(" "),t("p",[t("strong",[_._v("缺点：")]),_._v(" Copy On Write时如果父子进程大量写操作会导致分页错误。")]),_._v(" "),t("p",[t("strong",[_._v("参考：")])]),_._v(" "),t("ol",[t("li",[t("a",{attrs:{href:"https://www.cnblogs.com/ysocean/p/9114268.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("Redis详解（六）------ RDB 持久化 - YSOcean - 博客园 (cnblogs.com)"),t("OutboundLink")],1)]),_._v(" "),t("li",[t("a",{attrs:{href:"https://blog.csdn.net/Muscleape/article/details/105670481",target:"_blank",rel:"noopener noreferrer"}},[_._v("Redis-关于RDB的几点顿悟-COW（Copy On Write）_Muscleape的博客-CSDN博客"),t("OutboundLink")],1)])]),_._v(" "),t("h2",{attrs:{id:"aof"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aof"}},[_._v("#")]),_._v(" AOF")]),_._v(" "),t("p",[_._v("AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，因为这个模式是"),t("strong",[_._v("只追加")]),_._v("的方式，所以没有任何磁盘寻址的开销，所以很快，有点像 Mysql 中的binlog。AOF更适合做热备。")]),_._v(" "),t("p",[t("strong",[_._v("优点：")]),_._v(" AOF是一秒一次去通过一个后台的线程fsync操作，数据丢失不用怕。")]),_._v(" "),t("p",[t("strong",[_._v("缺点：")])]),_._v(" "),t("ol",[t("li",[_._v("对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在"),t("strong",[_._v("恢复")]),_._v("大数据集时的速度比 AOF 的恢复速度要快。")]),_._v(" "),t("li",[_._v("根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的。")])]),_._v(" "),t("h3",{attrs:{id:"执行流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行流程"}},[_._v("#")]),_._v(" 执行流程")]),_._v(" "),t("ol",[t("li",[_._v("命令的实时写入，不同级别可能有1秒数据损失。命令先追加到"),t("code",[_._v("aof_buf")]),_._v("然后再同步到AO磁盘，"),t("strong",[_._v("如果实时写入磁盘会带来非常高的磁盘IO，影响整体性能")]),_._v("。")]),_._v(" "),t("li",[_._v("对aof文件的"),t("strong",[_._v("重写")]),_._v("，目的是为了减少AOF文件的大小，可以自动触发或者手动触发("),t("strong",[_._v("BGREWRITEAOF")]),_._v(")，Fork出子进程操作，期间Redis服务仍可用。")])]),_._v(" "),t("p",[_._v("流程图如下：")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://img.xiaoyou66.com/2021/03/21/61cdc99df3f70.png",alt:"图片"}})]),_._v(" "),t("p",[t("strong",[_._v("注意事项：")])]),_._v(" "),t("ol",[t("li",[_._v("在重写期间，由于主进程依然在响应命令，为了保证最终备份的完整性；它"),t("code",[_._v("依然会写入旧")]),_._v("的AOF中，如果重写失败，能够保证数据不丢失")]),_._v(" "),t("li",[_._v("为了把重写期间响应的写入信息也写入到新的文件中，因此也会"),t("code",[_._v("为子进程保留一个buf")]),_._v("，防止新写的file丢失数据")]),_._v(" "),t("li",[_._v("重写是直接把"),t("code",[_._v("当前内存的数据生成对应命令")]),_._v("，并不需要读取老的AOF文件进行分析、命令合并")]),_._v(" "),t("li",[t("strong",[_._v("无论是 RDB 还是 AOF 都是先写入一个临时文件，然后通过"),t("code",[_._v("rename")]),_._v("完成文件的替换工作")])])]),_._v(" "),t("p",[t("strong",[_._v("fork的建议：")])]),_._v(" "),t("ol",[t("li",[_._v("降低fork的频率，比如可以手动来触发RDB生成快照、与AOF重写")]),_._v(" "),t("li",[_._v("控制Redis最大使用内存，防止fork耗时过长")]),_._v(" "),t("li",[_._v("合理配置Linux的内存分配策略，避免因为物理内存不足导致fork失败")]),_._v(" "),t("li",[_._v("Redis在执行"),t("code",[_._v("BGSAVE")]),_._v("和"),t("code",[_._v("BGREWRITEAOF")]),_._v("命令时，哈希表的负载因子>=5，而未执行这两个命令时>=1。目的是"),t("strong",[_._v("尽量减少写操作")]),_._v("，避免不必要的内存写入操作")]),_._v(" "),t("li",[t("strong",[_._v("哈希表的扩展因子")]),_._v("：哈希表已保存节点数量 / 哈希表大小。因子决定了是否扩展哈希表")])]),_._v(" "),t("h2",{attrs:{id:"恢复"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#恢复"}},[_._v("#")]),_._v(" 恢复")]),_._v(" "),t("p",[_._v("启动时会先检查AOF(数据更完整)文件是否存在，如果不存在就尝试加载RDB。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://img.xiaoyou66.com/2021/03/21/f5e3fbb0d1606.png",alt:"图片"}})]),_._v(" "),t("h2",{attrs:{id:"建议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#建议"}},[_._v("#")]),_._v(" 建议")]),_._v(" "),t("p",[_._v("既然单独用RDB会丢失很多数据。单独用AOF，数据恢复没RDB来的快，所以出现问题了第一时间用RDB恢复，然后AOF做数据补全。")])])}),[],!1,null,null,null);v.default=o.exports}}]);