(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{446:function(t,e,r){"use strict";r.r(e);var v=r(21),a=Object(v.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"jvm内存模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#jvm内存模型"}},[t._v("#")]),t._v(" JVM内存模型")]),t._v(" "),r("p",[t._v("这里主要还是会问一些Java的内存模型，1.8之前和之后的内存模型是不一样的")]),t._v(" "),r("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://img.xiaoyou66.com/2021/03/23/3c6944d4abc54.png",alt:"在这里插入图片描述"}}),t._v(" "),r("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://img.xiaoyou66.com/2021/03/23/0a4fc0f52a05b.png",alt:"在这里插入图片描述"}}),t._v(" "),r("p",[t._v("简单说一下每个部分是干嘛的吧")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("程序计数器")]),t._v("  用于记录程序执行的位置（字节码解释器可以改变这个来选取下一条执行的指令）")]),t._v(" "),r("li",[r("strong",[t._v("虚拟机栈")]),t._v("  描述的是java方法执行的内存模型，每个方法执行都会创建一个"),r("strong",[t._v("栈帧")]),t._v("，栈帧包含局部变量表、操作数栈、动态连接、方法出口等。")]),t._v(" "),r("li",[r("strong",[t._v("本地方法栈")]),t._v("  本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一，本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现StackOverFlowError 和 OutOfMemoryError 两种错误。")]),t._v(" "),r("li",[r("strong",[t._v("堆")]),t._v("  Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。"),r("strong",[t._v("此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。")])]),t._v(" "),r("li",[r("strong",[t._v("方法区")]),t._v("   与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。")]),t._v(" "),r("li",[r("strong",[t._v("元空间")]),t._v("  jdk1.8之后，就把方法区放到元空间了，元空间直接放到本地内存了（这样我们就不用担心之前永久代内存溢出的问题，只要本地内存足够，就不会出现java.lang.OutOfMemoryError: PermGen space的错误）")])]),t._v(" "),r("p",[t._v("还有一个更加详细的")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://img.xiaoyou66.com/2021/03/30/ee57504a3b1e1.jpg",alt:"img"}})]),t._v(" "),r("p",[t._v("参考：")]),t._v(" "),r("ol",[r("li",[r("a",{attrs:{href:"https://blog.csdn.net/weixin_44777669/article/details/114745089?spm=1001.2014.3001.5502",target:"_blank",rel:"noopener noreferrer"}},[t._v("JVM基础知识和调优_冷雨清的博客-CSDN博客_jvm调优"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://juejin.cn/post/6844903983400632327",target:"_blank",rel:"noopener noreferrer"}},[t._v("JVM之虚拟机栈详解 (juejin.cn)"),r("OutboundLink")],1)])]),t._v(" "),r("h3",{attrs:{id:"happens-before是啥"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#happens-before是啥"}},[t._v("#")]),t._v(" happens-before是啥")]),t._v(" "),r("p",[t._v("这个东西主要是为了解决并发编程中多线程的可见性。")]),t._v(" "),r("p",[t._v("为了方便程序员开发，将底层的烦琐细节屏蔽掉，JMM定义了Happens-Before原则。只要我们理解了Happens-Before原则，无需了解JVM底层的内存操作，就可以解决在并发编程中遇到的变量可见性问题。")]),t._v(" "),r("p",[t._v("JVM定义的Happens-Before原则是一组偏序关系："),r("strong",[t._v("对于两个操作A和B，这两个操作可以在不同的线程中执行。如果A Happens-Before B，那么可以保证，当A操作执行完后，A操作的执行结果对B操作是可见的。")])]),t._v(" "),r("p",[t._v("Happens-Before的规则包括：")]),t._v(" "),r("ol",[r("li",[t._v("程序顺序规则")]),t._v(" "),r("li",[t._v("锁定规则")]),t._v(" "),r("li",[t._v("volatile变量规则")]),t._v(" "),r("li",[t._v("线程启动规则")]),t._v(" "),r("li",[t._v("线程结束规则")]),t._v(" "),r("li",[t._v("中断规则")]),t._v(" "),r("li",[t._v("终结器规则")]),t._v(" "),r("li",[t._v("传递性规则")])]),t._v(" "),r("p",[t._v("参考")]),t._v(" "),r("ol",[r("li",[r("a",{attrs:{href:"https://segmentfault.com/a/1190000011458941",target:"_blank",rel:"noopener noreferrer"}},[t._v("从Java多线程可见性谈Happens-Before原则 - SegmentFault 思否"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=a.exports}}]);