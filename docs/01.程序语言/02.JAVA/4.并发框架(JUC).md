---
title: 并发框架(JUC)
date: 2021-03-20 15:46:19
permalink: /pages/f47c61/
categories:
  - 程序语言
  - JAVA
tags:
  - 
---

并发框架，其实也叫 JUC 即 `java.util.concurrent` 包，分为（锁框架、原子类框架、同步器框架、集合框架、执行器框架）

## 线程创建方式

- 继承`Thread`类重写run方法

  ```java
  public class Thread1 extends Thread {
      /**
       * 在run方法中实现业务代码
       */
      @Override
      public void run(){
          System.out.println(Thread.currentThread().getName()+"我是子线程");
  
      }
      public static void main(String[] args) {
          System.out.println(Thread.currentThread().getName()+"我是主线程");
          //不能直接使用run()方法，这就不属于开启线程，而是调用一个方法
          new Thread1().start();
      }
  }
  ```

- 实现`Runnable`接口

  ```java
  public class Thread2 implements Runnable {
      /**
       * 在run方法中实现业务代码
       */
      @Override
      public void run() {
          System.out.println(Thread.currentThread().getName() + "我是子线程");
      }
      public static void main(String[] args) {
          System.out.println(Thread.currentThread().getName() + "我是主线程");
          //这里要通过new Thread()的方式来开启
          new Thread(new Thread2()).start();
          //简化版 lambdas
          new Thread(() -> System.out.println(Thread.currentThread().getName() + "我是子线程")).start();
      }
  }
  
  ```

- 继承`Callable`

  ```java
  public class Thread3 implements Callable<String> {
      @Override
      public String call() throws Exception {
          try {
              System.out.println(Thread.currentThread().getName() + "我是子线程");
              Thread.sleep(2000);
          } catch (Exception e) {
              System.out.println(e.getMessage());
          }
          return "异步调用成功";
      }
  
      public static void main(String[] args) throws ExecutionException, InterruptedException {
          FutureTask<String> futureTask = new FutureTask<>(new Thread3());
          new Thread(futureTask).start();
          System.out.println(futureTask.get());
      }
  } 
  ```

- 使用线程池

参考：[线程学习1（小白自学）_冷雨清的博客-CSDN博客](https://blog.csdn.net/weixin_44777669/article/details/108813951)

## 线程的6种状态

![线程状态图](https://img.xiaoyou66.com/2021/03/30/6778942ce47c4.jpeg)

1. **初始(NEW)**：新创建了一个线程对象，但还没有调用start()方法。
2.  **运行(RUNNABLE)**：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。
   线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。
3.  **阻塞(BLOCKED)**：表示线程阻塞于锁。
4.  **等待(WAITING)**：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
5. **超时等待(TIMED_WAITING)**：该状态不同于WAITING，它可以在指定的时间后自行返回。
6. **终止(TERMINATED)**：表示该线程已经执行完毕。

## synchronized关键字（同步代码块）

synchronized可以修饰**实例方法**、**静态方法**、**代码块**，只需要加个关键字就行了

```java
public class Test {
    // 这里我们修饰了静态方法
    public synchronized void husband(){
    }
}
```

### synchronized如何实现线程同步

任何一个对象都由下面三个部分组成： 对象头+实例数据+填充数据

主要涉及到对象头和Monitor这两个概念

#### 对象头

synchronized是悲观锁，在操作同步资源的时候会给同步资源加上锁，这把锁就放在对象头里。以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。

**Mark Word**： 默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。

**Klass Point**： 对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

#### Monitor

Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。

Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。

总结一下就是：synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。

### 底层实现

我们用一个最简单的功能来举例，下面这个就是我们的代码

![image-20210407140619560](https://img.xiaoyou66.com/2021/04/07/34d4994b44a27.png)

我们编译为字节码后，效果如下

![image-20210407140650409](https://img.xiaoyou66.com/2021/04/07/424db2859b44c.png)

我们可以清晰段看到，其实synchronized映射成字节码指令就是增加来两个指令：monitorenter和monitorexit。当一条线程进行执行的遇到monitorenter指令的时候，它会去尝试获得锁，如果获得锁那么锁计数+1（为什么会加一呢，因为它是一个可重入锁，所以需要用这个锁计数判断锁的情况），如果没有获得锁，那么阻塞。当它遇到monitorexit的时候，锁计数器-1，当计数器为0，那么就释放锁。

那么有的朋友看到这里就疑惑了，那图上有2个monitorexit呀？马上回答这个问题：上面我以前写的文章也有表述过， **synchronized锁释放有两种机制，一种就是执行完释放；另外一种就是发送异常，虚拟机释放** 。图中第二个monitorexit就是发生异常时执行的流程，这就是我开头说的“会有2个流程存在“。而且，从图中我们也可以看到在第13行，有一个goto指令，也就是说如果正常运行结束会跳转到19行执行。

### 锁升级过程

为什么需要锁升级呢，因为我们monitor默认使用的是Mutex Lock，这东西实际上是一个重锁，非常消耗资源，在JDK6中，为了减少性能消耗，就引入了锁升级的概念，具体过程如下

无锁->偏向锁->轻量级锁 ->重量级锁 （过程不可逆）

![img](https://img.xiaoyou66.com/2021/03/30/626fc95178e8b.jpg)

#### 无锁

无锁不会对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。

无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。本质上就是通过CAS来实现的

#### 偏向锁

偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。

在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。

当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。

偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。

偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。

#### 轻量级锁

是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。

在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。

拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。

如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。

如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。

若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。

#### 重量级锁

升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。

综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。

### 对象锁和类锁

java的对象锁和类锁：java的对象锁和类锁在锁的概念上基本上和内置锁是一致的，但是，两个锁实际是有很大的区别的，对象锁是用于对象实例方法，或者一个实例对象上的，类锁是用于类的静态方法或者一个类的class对象上的。我们知道，类的实例对象可以有很多个，但是每个类只有一个class对象，所以不同实例对象的对象锁是互不干扰的，但是每个类只有一个类锁。但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别的。

**对象锁**

当一个对象中有同步方法或者同步块，线程调用此对象进入该同步区域时，必须获得对象锁。如果此对象的对象锁被其他调用者占用，则进入阻塞队列，等待此锁被释放（同步块正常返回或者抛异常终止，由JVM自动释放对象锁）。
注意，方法锁也是一种对象锁。当一个线程访问一个带synchronized方法时，由于对象锁的存在，所有加synchronized的方法都不能被访问（前提是在多个线程调用的是同一个对象实例中的方法）。

```java
public class object {
	public synchronized void method(){
		System.out.println("我是对象锁也是方法锁");
	}
}

public class object {
	public void method(){
		synchronized(this){
			System.out.println("我是对象锁");
	}
}
```

**类锁**

一个class其中的静态方法和静态变量在内存中只会加载和初始化一份，所以，一旦一个静态的方法被申明为synchronized，此类的所有的实例化对象在调用该方法时，共用同一把锁，称之为类锁。

```java
public class object {
	public static synchronized void method(){
		System.out.println("我是第一种类锁");
	}
}
public class object {
	public void method(){
		synchronized (object.this) {
			System.out.println("我是第二种类锁")
		}
	}
}
```

### 更深一层

如果再深入到源码来说，synchronized实际上有两个队列waitSet和entryList。

1. 当多个线程进入同步代码块时，首先进入entryList
2. 有一个线程获取到monitor锁后，就赋值给当前线程，并且计数器+1
3. 如果线程调用wait方法，将释放锁，当前线程置为null，计数器-1，同时进入waitSet等待被唤醒，调用notify或者notifyAll之后又会进入entryList竞争锁
4. 如果线程执行完毕，同样释放锁，计数器-1，当前线程置为null

![img](https://img.xiaoyou66.com/2021/03/30/c82b1212a6bc0.jpg)

参考

1. [死磕Synchronized底层实现 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453142528&idx=1&sn=34b26e408e1f8adcd8d8257522705171)
2. [【基本功】不可不说的Java“锁”事 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/50098743)
3. [面试官：请说一下对象锁和类锁的区别 - 风的姿态 - 博客园 (cnblogs.com)](https://www.cnblogs.com/fengzheng/p/12066239.html)
4. [如果你是一个 Java 面试官，你会问哪些问题？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/443280657/answer/1785592611)

## ReentrantLock（可重入锁）

相比于synchronized，ReentrantLock需要显式的获取锁和释放锁，相对现在基本都是用JDK7和JDK8的版本，ReentrantLock的效率和synchronized区别基本可以持平了。他们的主要区别有以下几点：

1. 等待可中断，当持有锁的线程长时间不释放锁的时候，等待中的线程可以选择放弃等待，转而处理其他的任务。
2. 公平锁：synchronized和ReentrantLock默认都是非公平锁，但是ReentrantLock可以通过构造函数传参改变。只不过使用公平锁的话会导致性能急剧下降。
3. 绑定多个条件：ReentrantLock可以同时绑定多个Condition条件对象。

ReentrantLock基于AQS(**AbstractQueuedSynchronizer 抽象队列同步器**)实现。

## Volatile关键字

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

- 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。

- 禁止进行指令重排序（为了提高性能，CPU会修改指令的执行顺序）。

### Volatile如何保证指令不会重排序

使用了内存屏障技术，在生成指令系列时在适当的位置会插入`内存屏障`指令来禁止特定类型的处理器重排序。

### 可见性是如何保证的

使用了 **MESI（IllinoisProtocol 缓存一致性协议）** 来保证指令一致性

> 当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。
>
> 怎么发现数据是否失效？（使用了嗅探技术）

### Volatile为什么不能保证原子性

Java中只有对基本类型变量的赋值和读取是原子操作，如i = 1的赋值操作，但是像j = i或者i++这样的操作都不是原子操作，因为他们都进行了多次原子操作，比如先读取i的值，再将i的值赋值给j，两个原子操作加起来就不是原子操作了。

所以，如果一个变量被volatile修饰了，那么肯定可以保证每次读取这个变量值的时候得到的值是最新的，但是一旦需要对变量进行自增这样的非原子操作，就不会保证这个变量的原子性了。

所以一般情况下我们只对volatile进行读取操作，而不是修改操作。

### 运用

单例模式里面用的到，单例有8种写法，其中有一种叫双重检验用到了这个

![image-20210323102329952](https://img.xiaoyou66.com/2021/03/23/e60fff5a75c8a.png)

参考：[面试官想到，一个Volatile，敖丙都能吹半小时 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453142004&idx=1&sn=81ccddb6c8b37114c022c4ad50368ecf)

## final关键字

final在Java中是一个保留的关键字，可以声明成员变量、方法、类以及本地变量。一旦你将引用声明作final，你将不能改变这个引用了，编译器会检查代码，如果你试图将变量再次初始化的话，编译器会报编译错误。

final变量经常和static关键字一起使用，作为常量。

### final方法

final也可以声明方法。方法前面加上final关键字，代表这个方法不可以被子类的方法 **重写** 。如果你认为一个方法的功能已经足够完整了，子类中不需要改变的话，你可以声明此方法为final。final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定。

### final类

使用final来修饰的类叫作final类。final类通常功能是完整的，它们不能被继承。Java中有许多类是final的，譬如String, Interger以及其他包装类。

### final关键字的好处

1. final关键字提高了性能。JVM和Java应用都会缓存final变量。
2. final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。
3. 使用final关键字，JVM会对方法、变量及类进行优化。

### 总结

1. final关键字可以用于成员变量、本地变量、方法以及类。
2. final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。
3. 你不能够对final变量再次赋值。
4. 本地变量必须在声明时赋值。
5. 在匿名类中所有变量都必须是final变量。
6. final方法不能被重写。
7. final类不能被继承。
8. final关键字不同于finally关键字，后者用于异常处理。
9. final关键字容易与finalize()方法搞混，后者是在Object类中定义的方法，是在垃圾回收之前被JVM调用的方法。
10. 接口中声明的所有变量本身是final的。
11. final和abstract这两个关键字是反相关的，final类就不可能是abstract的。
12. final方法在编译阶段绑定，称为静态绑定(static binding)。
13. 没有在声明时初始化final变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。
14. 将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化。
15. 按照Java代码惯例，final变量就是常量，而且通常常量名要大写：

参考： 

[深入理解Java中的final关键字 - qtyy - 博客园 (cnblogs.com)](https://www.cnblogs.com/chihirotan/p/6044056.html)

## 阻塞队列

默认使用的队列都是非阻塞的，不会阻塞当前线程，而阻塞队列会阻塞当前线程， **常用于线程池和生产者消费者的问题中**

当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。

**延时阻塞队列（DelayQueue）**  只有当其指定的延迟时间到了，才能够从队列中获取到该元素

深入参考：[Java并发编程-阻塞队列(BlockingQueue)的实现原理_记忆力不好的博客-CSDN博客_阻塞队列原理](https://blog.csdn.net/chenchaofuck1/article/details/51660119)

## ThreadLocal

通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？ 使用**ThreadLocal**类。 ThreadLocal可以让每个线程绑定自己的值。

![image.png](https://img.xiaoyou66.com/2021/03/23/a91165f5123c1.png)

- 使用 `get（）` 和 `set（）` 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。

- 每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为key的键值对，value其实就是我们存储数据的地方

#### ThreadLocal内存泄露的问题

- 使用static的ThreadLocal，延长了ThreadLocal的生命周期，可能导致内存泄漏。
- 分配使用了ThreadLocal又不再调用get(),set(),remove()方法，那么就会导致内存泄漏，因为这块内存一直存在。

**原因**

ThreadLocal在保存的时候会把自己当做Key存在ThreadLocalMap中，正常情况应该是key和value都应该被外界强引用才对，但是现在key被设计成WeakReference弱引用了。

参考：[JUC学习：ThreadLocal_冷雨清的博客-CSDN博客](https://blog.csdn.net/weixin_44777669/article/details/109511569)

## Java里面的各种锁

我之前还以为是什么各种类呢，实际上就是一些锁的概念，可以用下面这张图来概括

![img](https://img.xiaoyou66.com/2021/03/30/88270d14387dc.jpg)

### 乐观锁和悲观锁

悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。

而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。

- 悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。
- 乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。

### 自旋锁 VS 适应性自旋锁

**问题引入**

阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。

在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。

而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。

**自旋锁缺点**

它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。

**适应性自旋锁**

自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。

### 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁

这四种锁是指锁的状态，专门针对synchronized的。具体内容介绍在本文的synchronized关键字里会进行简单介绍

### 公平锁 VS 非公平锁

公平锁是指多个线程 **按照申请锁的顺序来获取锁** ，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。

非公平锁是多个线程 **加锁时直接尝试获取锁** ，**获取不到才会到等待队列的队尾等待** 。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。

综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。

### 可重入锁 VS 非可重入锁

可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。

![img](https://img.xiaoyou66.com/2021/03/30/9d3dc7c3b7a4f.jpg)

在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。

如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。

- ReentrantLock和synchronized都是重入锁


### 独享锁 VS 共享锁

独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。

共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。

独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。

参考：[java中的各种锁详细介绍 - JYRoy - 博客园 (cnblogs.com)](https://www.cnblogs.com/jyroy/p/11365935.html)

## 线程池

J.U.C提供的线程池：ThreadPoolExecutor类

**线程池的好处**

- **降低资源消耗**：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。
- **提高响应速度**：任务到达时，无需等待线程创建即可立即执行。
- **提高线程的可管理性**：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。
- **提供更多更强大的功能**：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。

### 常用线程池

1. Executors.newCachedThreadPool()  可缓存线程池，这个是一个无界的队列
2. Executors.newFixedThreadPool(int n)：创建一个可重用固定个数的线程池。
3. Executors.newScheduledThreadPool(int n)：创建一个定长线程池，支持定时及周期性任务执行。
4. xecutors.newSingleThreadExecutor()：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

### 线程池使用

```java
// 创建固定大小的线程池:
ExecutorService executor = Executors.newFixedThreadPool(3);
// 提交任务: 返回一个future。可以用这个future来判断任务是否成功完成
executor.submit(task1);
// 提交任务: 没有返回值。可以执行任务，但无法判断任务是否成功完成。
executor.execute(task1);
// 关闭线程池: 在线程池队列中的提交的任务会执行，无法提交新的任务，注意调用这个方法，线程池不会等待（wait）在执行的任务执行完成，可以使用awaitTermination实现这个目的。这里需要注意的是：在执行的任务因为是异步线程执行的，任务还是会继续执行，只是说线程池不会阻塞等待任务执行完成
executor.shutdown();
// 试图关闭正在执行的任务，不会执行已经提交到队列但是还没有执行的任务，返回等待执行的任务列表，同时此方法不会等待那些正在执行的任务执行完，等待执行的任务会从线程池队列移除。
executor.shutdownNow()

```

### 线程池参数

```java
public ThreadPoolExecutor(int corePoolSize,  // 线程池的核心线程数
                          int maximumPoolSize, // 线程池的最大线程数
                          long keepAliveTime, // 当线程数大于核心时，多余的空闲线程等待新任务的存活时间。
                          TimeUnit unit, // keepAliveTime的时间单位
                          ThreadFactory threadFactory, // 线程工厂
                          BlockingQueue<Runnable> workQueue,// 用来储存等待执行任务的队列
                          RejectedExecutionHandler handler // 拒绝策略
                          ) 
```

- **corePoolSize**  线程池保留的最小线程数。一开始是不会立即启动的，线程会慢慢增加，直到达到这个数为止，如果线程池中的线程少于此数目，（当然我们也可以调用prestartAllCoreThreads方法来创建所有的线程）则在执行execut()时创建。

- **maximumPoolSize**  线程池中允许拥有的最大线程数。

- **keepAliveTime、unit** 只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用

  当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；

- **threadFactory**    使用默认的即可

- **workQueue** 工作队列，存放提交的等待任务，其中有队列大小的限制

- **handler** 拒绝策略，有以下四种取值：
  AbortPolicy（默认）：丢弃任务并抛出RejectedExecutionException异常。
  CallerRunsPolicy：由调用线程处理该任务。(例如io操作，线程消费速度没有NIO快，可能导致阻塞队列一直增加，此时可以使用这个模式)
  DiscardPolicy：丢弃任务，但是不抛出异常。 （可以配合这种模式进行自定义的处理方式）
  DiscardOldestPolicy：丢弃队列最早的未处理任务，然后重新尝试执行任务（重复执行）

### 三种阻塞队列

首先看一下新任务进入时线程池的执行策略：
如果运行的线程少于corePoolSize，则 Executor始终首选添加新的线程，而不进行排队。（如果当前运行的线程小于corePoolSize，则任务根本不会存入queue中，而是直接运行）
如果运行的线程大于等于 corePoolSize，则 Executor始终首选将请求加入队列，而不添加新的线程。
如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。
主要有3种类型的BlockingQueue：

- **无界队列** 队列大小无限制，常用的为无界的LinkedBlockingQueue，使用该队列做为阻塞队列时要尤其当心，当任务耗时较长时可能会导致大量新任务在队列中堆积最终导致OOM。最近工作中就遇到因为采用LinkedBlockingQueue作为阻塞队列，部分任务耗时80s＋且不停有新任务进来，导致cpu和内存飙升服务器挂掉。
- **有界队列** 常用的有两类，一类是遵循FIFO原则的队列如ArrayBlockingQueue与有界的LinkedBlockingQueue，另一类是优先级队列如PriorityBlockingQueue。PriorityBlockingQueue中的优先级由任务的Comparator决定。
  使用有界队列时队列大小需和线程池大小互相配合，线程池较小有界队列较大时可减少内存消耗，降低cpu使用率和上下文切换，但是可能会限制系统吞吐量。
- **同步移交** 如果不希望任务在队列中等待而是希望将任务直接移交给工作线程，可使用SynchronousQueue作为等待队列。SynchronousQueue不是一个真正的队列，而是一种线程之间移交的机制。要将一个元素放入SynchronousQueue中，必须有另一个线程正在等待接收这个元素。只有在使用无界线程池或者有饱和策略时才建议使用该队列。

### 四种拒绝策略

- **AbortPolicy中止策略** 使用该策略时在饱和时会抛出RejectedExecutionException（继承自RuntimeException），调用者可捕获该异常自行处理。
- **DiscardPolicy抛弃策略** 不做任何处理直接抛弃任务
- **DiscardOldestPolicy抛弃旧任务策略** 先将阻塞队列中的头元素出队抛弃，再尝试提交任务。如果此时阻塞队列使用PriorityBlockingQueue优先级队列，将会导致优先级最高的任务被抛弃，因此不建议将该种策略配合优先级队列使用。
- **CallerRunsPolicy调用者运行** 既不抛弃任务也不抛出异常，直接运行任务的run方法，换言之将任务回退给调用者来直接运行。使用该策略时线程池饱和后将由调用线程池的主线程自己来执行任务，因此在执行任务的这段时间里主线程无法再提交新任务，从而使线程池中工作线程有时间将正在处理的任务处理完成。

### 合理配置线程池核心线程数（IO密集型和CPU密集型）

**CPU密集型**

CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行。
CPU密集任务只有在真正的多核CPU上才可能得到加速（通过多线程），而在单核CPU上，无论你开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那些。
CPU密集型任务配置尽可能少的线程数量：
一般公式：**CPU核数+1个线程的线程池**

**IO密集型**

IO包括：数据库交互，文件上传下载，网络传输等
方法一： 由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如**CPU核数\*2**
方法二： IO密集型，即该任务需要大量的IO，即大量的阻塞。
在单线程上运IO密集型的任务会导致浪费大量的CPU运算能力浪费在等待。
所以在IO密集型任务中使用多线程可以大大的加速程序运行，即使在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间。
IO密集型时，大部分线程都阻塞，故需要多配置线程数：
参考公式：**CPU核数 /（1 - 阻系数）**
比如8核CPU：8/(1 - 0．9)=80个线程数
阻塞系数在0.8~0.9之间

### JUC底层源码分析

![在这里插入图片描述](https://img.xiaoyou66.com/2021/04/23/c672c91340eac.png)

![在这里插入图片描述](https://img.xiaoyou66.com/2021/04/23/3e844dfc6294b.png)

参考：

1. [Java线程池实现原理及其在美团业务中的实践 - 美团技术团队 (meituan.com)](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)
2. [java常用线程池 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/92790574)
3. [Java中如何正确的关闭线程池ExecutorService_zlp1992的专栏-CSDN博客](https://blog.csdn.net/zlp1992/article/details/104197515)
4. [线程池的参数详解_meihuai7538的博客-CSDN博客_线程池参数](https://blog.csdn.net/meihuai7538/article/details/104876674)
5. [java线程池与五种常用线程池策略使用与解析_徐刚的技术博客-CSDN博客_常用的线程池模式以及不同线程池的使用场景](https://blog.csdn.net/u011479540/article/details/51867886)
6. [JUC学习：线程池_冷雨清的博客-CSDN博客](https://blog.csdn.net/weixin_44777669/article/details/108735557)

## 线程阻塞

线程阻塞的几个方法

- **线程睡眠** Thread.sleep (long millis)方法当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。

- **线程等待**  Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 唤醒方法。

- **线程礼让** Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程.

- **线程自闭** join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。

- **suspend() 和 resume()**   两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。**Thread中suspend()和resume()两个方法在JDK1.5中已经废除**，不再介绍。因为有死锁倾向。

![image.png](https://img.xiaoyou66.com/2021/03/23/a1eb1a5d42116.png)

参考：[Java中什么方法导致线程阻塞_Chin_Style的博客-CSDN博客_java 线程阻塞](https://blog.csdn.net/weixin_41101173/article/details/79679300)

## synchronized与Lock的区别

我还以为Lock是啥玩意，其实Lock只是一个接口（特地看了一下java的源码），然后java里面有好几个实现了这个接口，其中最著名的就是 `ReentrantLock` 了。先说一下大概的区别

| 类别     | synchronized                                                 | Lock                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 存在层次 | Java的关键字，在jvm层面上                                    | 是一个类                                                     |
| 锁的释放 | 1、以获取锁的线程执行完同步代码，释放锁 2、线程执行发生异常，jvm会让线程释放锁 | 在finally中必须释放锁，不然容易造成线程死锁                  |
| 锁的获取 | 假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待   | 分情况而定，Lock有多个锁获取的方式，具体下面会说道，大致就是可以尝试获得锁，线程可以不用一直等待 |
| 锁状态   | 无法判断                                                     | 可以判断                                                     |
| 锁类型   | 可重入 不可中断 非公平                                       | 可重入 可判断 可公平（两者皆可）                             |
| 性能     | 少量同步                                                     | 大量同步                                                     |

然后lock里面有下面几个方法

- lock()：获取锁，如果锁被暂用则一直等待
- unlock():释放锁
- tryLock(): 注意返回类型是boolean，如果获取锁的时候锁被占用就返回false，否则返回true
- tryLock(long time, TimeUnit unit)：比起tryLock()就是给了一个时间期限，保证等待参数时间
- lockInterruptibly()：用该锁的获得方式，如果线程在获取锁的阶段进入了等待，那么可以中断此线程，先去做别的事

这里说一下这东西怎么使用吧，首先就是需要加锁，最后我们再释放锁

```java
public class Counter {
    private final Lock lock = new ReentrantLock();
    private int count;

    public void add(int n) {
        lock.lock();
        try {
            count += n;
        } finally {
            lock.unlock();
        }
    }
}
```

具体回答（如果面试官问起来，我们可以这样回答）

- ReentrantLock 拥有Synchronized相同的并发性和内存语义，此外还多了 锁投票，定时锁等候和中断锁等候。线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定，如果使用 synchronized ，如果A不释放，B将一直等下去，不能被中断，如果 使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情
- synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定，但是使用Lock则不行，lock是通过代码实现的，要保证锁定一定会被释放，就必须将unLock()放到finally{}中
- 在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态；

**那么这两个东西应该如何选择呢**

synchronized原语和ReentrantLock在一般情况下没有什么区别，但是在非常复杂的同步应用中，请考虑使用ReentrantLock，特别是遇到下面2种需求的时候。

1.某个线程在等待一个锁的控制权的这段时间需要中断 2.需要分开处理一些wait-notify，ReentrantLock里面的Condition应用，能够控制notify哪个线程 3.具有公平锁功能，每个到来的线程都将排队等候

下面细细道来……

先说第一种情况，ReentrantLock的lock机制有2种，忽略中断锁和响应中断锁，这给我们带来了很大的灵活性。比如：如果A、B2个线程去竞争锁，A线程得到了锁，B线程等待，但是A线程这个时候实在有太多事情要处理，就是一直不返回，B线程可能就会等不及了，想中断自己，不再等待这个锁了，转而处理其他事情。这个时候ReentrantLock就提供了2种机制，第一，B线程中断自己（或者别的线程中断它），但是ReentrantLock不去响应，继续让B线程等待，你再怎么中断，我全当耳边风（synchronized原语就是如此)

第二，B线程中断自己（或者别的线程中断它），ReentrantLock处理了这个中断，并且不再等待这个锁的到来，完全放弃。

参考：

- [Synchronized与Lock的区别与应用场景一只特立独行的猪 (guanzhou.pub)](http://guanzhou.pub/2020/03/04/Sync-and-lock/)

## AQS

也叫AbstractQueuedSynchronizer（AQS），是一个抽象的队列式同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它（很多锁也是基于这个框架的），AQS示意图如下

![img](https://img.xiaoyou66.com/2021/03/29/3cb6b9426f9f9.png)

它维护了一个volatile int state（代表共享资源，使用volatile修饰）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。

节点的示意图如下

![image-20210329162754753](https://img.xiaoyou66.com/2021/03/29/df554a726285e.png)

### 相关属性和资源共享方式

**state的访问方式有三种**

- getState()
- setState()
- compareAndSetState()

AQS有**两种资源的共享方式**

- Exclusive（独占，只有一个线程能执行，如ReentrantLock）
- Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）

不同的自定义同步器争用共享资源的方式也不同。**自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可**，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：

- isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。
- tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。
- tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。
- tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
- tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。

**以ReentrantLock为例**，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。

一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。

### 节点状态

队列里面放的是节点，而节点是对每一个等待获取资源的线程的封装，其包含了需要同步的线程本身及其等待状态，如是否被阻塞、是否等待唤醒、是否已经被取消等。变量waitStatus则表示当前Node结点的等待状态，共有5种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE、0。

- **CANCELLED**(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。
- **SIGNAL**(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。
- **CONDITION**(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将**从等待队列转移到同步队列中**，等待获取同步锁。
- **PROPAGATE**(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。
- **0**：新结点入队时的默认状态。

> 注意，**负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用>0、<0来判断结点的状态是否正常**。

### 方法流程解读

下面我们按照独占和共享两种不同的方式来讲解里面的内容

#### 获取独占资源

![img](https://img.xiaoyou66.com/2021/03/29/1fc605c88d512.png)

#### 释放独占资源

此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源

#### 获取共享资源





参考：

1. [Java并发之AQS详解 - waterystone - 博客园 (cnblogs.com)](https://www.cnblogs.com/waterystone/p/4920797.html)

