---
title: 面试题
date: 2021-03-23 19:37:14
permalink: /pages/2e34d2/
categories:
  - 程序语言
  - JAVA
tags:
  - 
---
## 同学的一次面试

### 内存溢出的两种问题及原因

### java.lang.OutOfMemoryError

方法区主要存储类的元信息，实现在元数据区。当JVM发现元数据区没有足够的空间分配给加载的类时，抛出该异常。

### java.lang.StackOverflowError

`抛出这个错误表明应用程序因为深递归导致栈被耗尽了。`每当java程序启动一个新的线程时，java虚拟机会为他分配一个栈，java栈以帧为单位保持线程运行状态；当线程调用一个方法是，jvm压入一个新的栈帧到这个线程的栈中，只要这个方法还没返回，这个栈帧就存在。 如果方法的嵌套调用层次太多(如递归调用),随着java栈中的帧的增多，最终导致这个线程的栈中的所有栈帧的大小的总和大于-Xss设置的值，而产生生`StackOverflowError`溢出异常。

### 内存模型主要要回收那些类

不再使用的对象需要进行回收，不使用的类也有可能回收。

### 如何查看GC状态

使用`jstat`命令，（jstat [Options] vmid [interval] [count]）

**参数说明**

Options，选项，我们一般使用 -gcutil 查看gc情况
vmid，VM的进程号，即当前运行的java进程号
interval，间隔时间，单位为秒或者毫秒
count，打印次数，如果缺省则打印无数次

比如下面这里我们打印12538进程的GC情况

![image.png](https://img.xiaoyou66.com/2021/03/23/f6fed02e40cbf.png)

**使用阿里开源的Arthas**

参考

1. [Linux使用jstat命令查看jvm的GC情况_zlzlei的专栏-CSDN博客](https://blog.csdn.net/zlzlei/article/details/46471627)
2. [推荐一款阿里开源的 Java 诊断工具，好用到爆！ - SegmentFault 思否](https://segmentfault.com/a/1190000019925820)

### Bean是线程安全的吗

容器本身并没有提供Bean的线程安全策略，因此可以说Spring容器中的Bean本身不具备线程安全的特性，但是我们还需要结合不同的Bean进行研究

Spring 的 bean 作用域（scope）类型有5种：

1、singleton:单例，默认作用域。

2、prototype:原型，每次创建一个新对象。

3、request:请求，每次Http请求创建一个新对象，适用于WebApplicationContext环境下。

4、session:会话，同一个会话共享一个实例，不同会话使用不用的实例。

5、global-session:全局会话，所有会话共享一个实例。

Spring中的Bean默认是单例模式的，框架并没有对bean进行多线程的封装处理。实际上大部分时间Bean是无状态的（比如Dao） 所以说在某种程度上来说Bean其实是安全的。

参考： [面试：Spring 中的bean 是线程安全的吗？ - 云+社区 - 腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1743283)

### Sleep(0)可以干嘛

Thread.Sleep(0) 并非是真的要线程挂起0毫秒，意义在于这次调用Thread.Sleep(0)的当前线程确实的被冻结了一下，让其他线程有机会优先执行。Thread.Sleep(0) 是你的线程暂时放弃cpu，也就是释放一些未用的时间片给其他线程或进程使用，就相当于一个让位动作。

[Sleep(0)的妙用_HawkJony的博客-CSDN博客](https://blog.csdn.net/qiaoquan3/article/details/56281092)

## 大佬的面试题

### 堆分析器

使用**MAT**来进行分析

[Java堆分析器 - Eclipse Memory Analyzer Tool(MAT)_旧路-CSDN博客_java mat](https://blog.csdn.net/wuyuxing24/article/details/105456317)

### 静态变量什么时候会被回收

**静态成员一般也可以分为静态基本类型和静态引用类型。**

静态基本类型存储在在静态变量区域；静态引用类型的引用存储在静态变量区域，而实例（具体内容）存储在堆上。静态成员只存在一份，静态成员加载时机：类加载的时候（第一次访问），这个类中所有静态成员就会被加载在静态存储区，同时存储在[静态变量区域的成员一旦创建，直到程序退出才会被回收](https://blog.csdn.net/oTengYue/article/details/48108995#)。（注：如果是引用类型，如static student myst=new student()，myst=null这时候，在静态存储区里面存的是一个地址（myst），这个地址指向在堆里面创建的student实例对象，当myst=null的时候，在静态存储区里面的变量会一直存在，但是在堆里面的student实例对象因为没有变量指向它，所以会被回收）。因此如果不用的静态引用类型可以通过设置=null方式让GC可以回收其堆上的空间。

## 知乎上看到的

### 对象如何进行深拷贝，除了clone

特地谷歌了一下，发现居然还有很多方法

1. 使用构造函数进行深拷贝
2. 重载clone方法
3. 使用Apache Commons Lang进行序列化
4. 使用Gson序列化
5. 使用Jackson序列化

[Java如何对一个对象进行深拷贝？ - 吴大山的博客 | Wudashan Blog](https://wudashan.com/2018/10/14/Java-Deep-Copy/)

### happen-before原则

这个是java内存模型里的，具体参考

[JVM模型 | 面试问题浓缩总结 (xiaoyou66.com)](http://interview.xiaoyou66.com/pages/b38788/)

### 单例对象会被jvm的gc时回收吗

java中单例模式创建的对象被自己类中的静态属性所引用，符合第二条，因此，单例对象不会被jvm垃圾收集。

[Java中单例对象不会被GC回收_qq876551724的博客-CSDN博客](https://blog.csdn.net/qq876551724/article/details/78805138)

### wait()与sleep()的区别

简单来说wait()会释放对象锁而sleep()不会释放对象锁

### Synchronized(obj){...}是锁对象还是代码块？

锁的的是对象，因为会修改对象里面的内容

[阿里面试题深度解析：Synchronized(obj){...}是锁对象还是代码块？Why？_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili](https://www.bilibili.com/video/BV1A64y1Q7aD)



### 如何分析并找出内存泄漏的位置

- 在java运行程序的时候，我们可以加入 `-XX:+HeapDumpOnOutOfMemoryError` 参数，可以生成dump文件，然后当程序抛出异常后，在程序的classpath下会生成以一个以.hprof结尾的文件，我们可以使用 `IBM heapAnalyzer` 来分析head dump文件，并进行排查

- **Java VisualVM远程分析堆**

  就是这个工具，这个工具可以查看详细的内存信息

  ![image-20210407170434600](https://img.xiaoyou66.com/2021/04/07/72df99c895060.png)

参考：

- [【赵强老师】如何分析Java的内存溢出问题 - SegmentFault 思否](https://segmentfault.com/a/1190000022626513)



### java什么情况下会导致内存泄漏

内存泄漏的表现：

- 应用程序长时间连续运行时性能严重下降；
- 应用程序中的OutOfMemoryError堆错误；
- 自发且奇怪的应用程序崩溃；
- 应用程序偶尔会耗尽连接对象；

**导致内存泄漏的原因**

- 未关闭的资源导致内存泄漏

  每当创建连接或者打开流时，JVM都会为这些资源分配内存。如果没有关闭连接，会导致持续占有内存。在任意情况下，资源留下的开放连接都会消耗内存，如果不处理，就会降低性能，甚至OOM。

  解决办法：使用finally块关闭资源；关闭资源的代码，不应该有异常；JDK1.7之后，可以使用太try-with-resource块。

-  不正确的equals()和hashCode()

  在HashMap和HashSet这种集合中，常常用到equal()和hashCode()来比较对象，如果重写不合理，将会成为潜在的内存泄漏问题。

  解决办法：用最佳的方式重写equals()和hashCode().

- 引用了外部类的内部类

  非静态内部类的初始化，总是需要外部类的实例；默认情况下，每个非静态内部类都包含对其外部类的隐式引用，如果我们在应用程序中使用这个内部类对象，那么即使在我们的外部类对象超出范围后，它也不会被垃圾收集器清除掉。

  解决办法：如果内部类不需要访问外部类包含的类成员，可以转换为静态类。

- finalize方法导致的内存泄漏

  重写finalize()方法时，该类的对象不会立即被垃圾收集器收集，如果finalize()方法的代码有问题，那么会潜在的印发OOM；

  解决办法：避免重写finalize()方法。

- 使用ThreadLocal造成内存泄漏

  使用ThreadLocal时，每个线程只要处于存活状态就可保留对其ThreadLocal变量副本的隐式调用，且将保留其自己的副本。使用不当，就会引起内存泄漏。

  一旦线程不再存在，该线程的threadLocal对象就应该被垃圾收集，而现在线程的创建都是使用线程池，线程池有线程重用的功能，因此线程就不会被垃圾回收器回收。所以使用到ThreadLocal来保留线程池中的线程的变量副本时，ThreadLocal没有显式地删除时，就会一直保留在内存中，不会被垃圾回收。

  解决办法：不再使用ThreadLocal时，调用remove()方法，该方法删除了此变量的当前线程值。不要使用ThreadLocal.set(null)，它只是查找与当前线程关联的Map并将键值中这个threadLocal对象所对应的值为null，并没有清除这个键值对。



参考：

- [面试官：小伙子，你给我说一下Java中什么情况会导致内存泄漏呢？ - SegmentFault 思否](https://segmentfault.com/a/1190000023521531)