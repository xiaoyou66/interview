---
title: 索引
date: 2021-03-20 15:49:48
permalink: /pages/ec17ed/
categories:
  - 数据库
  - MySQL
tags:
  - 
---

## 概念

索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。

索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。

## 索引实现原理

InnoDB的索引使用的是B+树实现

### 索引的执行步骤

1. 把创建了索引的列的内容进行排序
2. 对排序结果生成倒排表
3. 在倒排表内容上拼上数据地址链
4. 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据

### 为什么使用B+树，而不是B树？

- IO次数少：B+树的中间结点只存放索引，数据都存在叶结点中，因此中间结点可以存更多的数据，让索引树更加矮胖；（ **注意不要答节省空间。并没有节省空间，要答我们的树更加矮胖，可以减少IO次数** ）
- 范围查询效率更高：B树需要中序遍历整个树，只B+树需要遍历叶结点中的链表；
- 查询效率更加稳定：每次查询都需要从根结点到叶结点，路径长度相同，所以每次查询的效率都差不多

### 为什么不用哈希索引？ 

哈希索引能以 O(1) 时间进行查找，但是只支持精确查找，无法用于部分查找和范围查找，无法用于排序与分组；B树索引支持大于小于等于查找，范围查找。哈希索引遇到大量哈希值相等的情况后查找效率会降低。哈希索引不支持数据的排序。

## 优缺点

**优点**

- 大大加快了数据的**检索速度**；
- 可以显著减少查询中**分组和排序**的时间；
- 通过创建唯一性索引，可以**保证**数据库表中每一行数据的**唯一性**；
- 将随机 I/O 变为**顺序 I/O**（B+Tree 索引是有序的，会将相邻的数据都存储在一起）

**缺点**

- 建立和维护索引耗费时间空间，更新索引很慢。

## 什么情况下索引会失效

- 以“%(表示任意0个或多个字符)”开头的LIKE语句；
- OR语句前后没有同时使用索引；
- 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）；
- 对于多列索引，必须满足 **最左匹配原则**/最左前缀原则 (最左优先，eg：多列索引col1、col2和col3，则 索引生效的情形包括 col1或col1，col2或col1，col2，col3)；
- 如果MySQL估计全表扫描比索引快，则不使用索引（比如非常小的表）

## 索引分类

![preview](https://img.xiaoyou66.com/2021/03/21/10b776c2ad7ae.jpg)

详细参考：[MySQL索引分类，90%的开发都不知道 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/115746492)

## 什么地方适合创建索引

- 某列经常作为最大最小值；
- 经常被查询的字段；
- 经常用作表连接的字段；
- 经常出现在ORDER BY/GROUP BY/DISDINCT后面的字段

## 创建索引注意事项

1. 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
2. 较频繁作为查询条件的字段才去创建索引
3. 更新频繁字段不适合创建索引
4. 若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)
5. 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。
6. 定义有外键的数据列一定要建立索引。
7. 对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。
8. 对于定义为text、image和bit的数据类型的列不要建立索引。

## 什么是索引覆盖

覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。

当索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引

## 索引算法

1. **BTree算法:**最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,>,>=,<,<=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量比如：`select * from user where name like 'jack%'`
2.  **Hash算法：**Hash索引只能用于对等比较，例如=,<=>（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引

## 创建和删除索引

### 在插入语句中加入KEY字段

```sql
CREATE TABLE user_index2 (
	id INT auto_increment PRIMARY KEY,
	first_name VARCHAR (16),
	last_name VARCHAR (16),
	id_card VARCHAR (18),
	information text,
	KEY name (first_name, last_name),
	FULLTEXT KEY (information),
	UNIQUE KEY (id_card) // 比如这里
);
```

### 使用ALTER TABLE命令

```sql
ALTER TABLE table_name ADD INDEX index_name (column_list);
```

ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。

其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。

### 使用CREATE INDEX命令创建

```sql
CREATE INDEX index_name ON table_name (column_list);
//CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）
```

### 删除索引

```sql
alter table user_index drop KEY name;
```

可以删除普通索引、唯一索引、全文索引：alter table 表名 drop KEY 索引名

**删除主键索引：**`alter table 表名 drop primary key`（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引），如果真的需要删除的话那么就需要取消自增长，再删除

## 索引一定能提高查询效率吗

通常通过索引查询数据比全表扫描要快，但是索引需要空间来存储，也需要定期维护，而且每次更新数据时需要同步更新索引，因此不必要的索引反而会使查询反应时间变慢

## 如何删除百万级别的数据

不能直接删除，因为直接删除同样会更新索引，这样会消耗额外的IO，一般情况下我们这样操作：

1. 先删除索引
2. 然后删除无用的数据
3. 重新创建索引

与之前的直接删除绝对是要快速很多，而且万一删除中断,一切删除会回滚，所消耗的时间更多！

## 前缀索引

就是使用字段的前几位来创建索引

**语法**：index(**field(10)**)，使用**字段值的前10个字符建立索引**，默认是使用字段的全部内容建立索引。

## 最左前缀原则？最左匹配原则？

**最左前缀匹配原则：**在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。主要包括以下两点

1. 按照文档, 更准确的说法应该是最左前缀原则, 即如果你创建一个**联合索引, 那 这个索引的任何前缀都会用于查询,** (col1, col2, col3)这个联合索引的所有前缀 就是(col1), (col1, col2), (col1, col2, col3), 包含这些列的查询都会启用索 引查询.
2. 其他所有**不在最左前缀里的列都不会启用索引, 即使包含了联合索引里的部分列 也不行**. 即上述中的(col2), (col3), (col2, col3) 都不会启用索引去查询.

参考：[官方文档解释MySQL最左匹配(最左前缀)原则 (juejin.cn)](https://juejin.cn/post/6844903966690508814)

## 聚簇索引和非聚簇索引

- 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据
- 非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因

深入参考[聚簇索引与非聚簇索引（也叫二级索引）--最清楚的一篇讲解 - 云+社区 - 腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1541265)

## 联合索引

使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。当你只用到了联合索引中的一个字段来查询时，MySQL就会按照最左匹配原则来进行匹配。









