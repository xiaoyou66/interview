---
title: 1-10
date: 2021-04-10 14:20:24
permalink: /pages/570ec8/
categories:
  - 算法和数据结构
  - 程序员面试
tags:
  - 
---

## 01.01判断字符串是否唯一

[面试题 01.01. 判定字符是否唯一 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/is-unique-lcci/)

![image-20210414103007732](https://img.xiaoyou66.com/2021/04/14/c4b0a5030bb6b.png)

### 解法一： 使用map

这个方法虽然很简单，但是面试不推荐的话不推荐使用这个方法

```go
func isUnique(astr string) bool {
   // 使用map暂存
   unique:=make(map[int32]bool)
   for _,v:=range astr{
      if unique[v] {
         return false
      }
      unique[v] = true
   }
   return true
}
```

### 解法二： bool数组

因为这个题目的范围已经定死了，在a-z这个范围内，所以我们可以使用一个bool数组来存储，当然了，这方法也不是很推荐

```go
func isUnique(astr string) bool {
   unique:=make([]bool,26)
   for i := 0; i < len(astr); i++ {
      if unique[astr[i]-'a'] {
         return false
      }
      unique[astr[i]-'a'] = true
   }
   return true
}
```

### 解法三：位运算

我们使用bool数组还是太浪费了，为了最大化的压缩空间，我们可以使用一个bit来表示。因为题目里的范围在0-26，所以我们可以使用int类型，int类型是4个字节，4*8=32位。

但是这个有个难点，那就是怎么判断这个字符是否出现了呢，可以使用与运算来判断重复，用或运算来进行赋值

go代码如下：

```go
func isUnique(astr string) bool {
   mask:=0
   for i := 0; i < len(astr); i++ {
      bitMove:=astr[i]-'a'
      if mask & (1<<bitMove) != 0 {
         return false
      } else {
         mask|=1<<bitMove
      }
   }
   return true
}
```

java代码如下：

```java
public boolean isUnique(String astr) {
    int mask = 0;
    byte[] data= astr.getBytes();
    for(byte a:data){
        int bitMove = a-'a';
        if ( (mask & (1<<bitMove)) != 0 ){
            return false;
        } else {
            mask |= 1<<bitMove;
        }
    }
    return true;
}
```

## 01.02 判定是否为字符重排

[面试题 01.02. 判定是否互为字符重排 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/check-permutation-lcci/)

![image-20210414171820707](https://img.xiaoyou66.com/2021/04/14/259cb70f7da0e.png)

### 解法一： 字符统计

我们使用一个数组来存储每个字母出现的次数，当然也可以使用map（但是更推荐用数组）

```go
func CheckPermutation(s1 string, s2 string) bool {
   // 使用data来存储数据
   data:=make([]int,26)
   // 首先遍历s1，统计一下
   for _,v:=range s1{
      data[v-'a']++
   }
   // 然后遍历s2，每个字符减1
   for _,v:=range s2{
      data[v-'a']--
   }
   // 最后我们遍历数据表，如果不为0直接返回false
   for _,v:=range data{
      if v != 0 {
         return false
      }
   }
   return true
}
```

### 解法二：对字符串进行排序

