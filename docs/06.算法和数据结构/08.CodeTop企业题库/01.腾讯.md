---
title: 腾讯
date: 2021-04-15 08:34:10
permalink: /pages/a04920/
categories:
  - 算法和数据结构
  - CodeTop企业题库
tags:
  - 
---
## 1.反转链表

[206. 反转链表 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/reverse-linked-list/)

![image-20210415083441164](https://img.xiaoyou66.com/2021/04/15/e183c0981ddaa.png)

这题考察的就是你对递归和迭代的综合运用

### 解法一：递归

这递归好久没做了，还有有点蒙，下面我简单说一下思路吧

```go
func reverseList(head *ListNode) *ListNode {
   // 先判断节点是否为空(如果节点的后一位为空，说明我们已经到达节点末尾了)
   if head == nil || head.Next == nil {
      return head
   }
   // 这里是理解的关键，这个递归他的目的就是直接到达链表的末尾
   res:=reverseList(head.Next)
   // 这里我们可以理解为head已经是尾结点了，所以我们需要修改一下方向
   head.Next.Next = head
   head.Next = nil
   return res
}
```

Java代码实现如下

```java
public ListNode reverseList(ListNode head) {
    if(head==null ||head.next==null){
        return head;
    }
    ListNode res = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return res;
}
```

### 解法二：迭代

我好菜啊，迭代都没想出来。。。。其实不难，主要是自己之前一直在想如何使用一个指针来实现，然后发现自己需要两个指针。。。。

```go
func reverseList(head *ListNode) *ListNode {
   // 设置前一个节点
   var prev *ListNode = nil
   // 然后设置当前节点
   var curr = head
   // 当当前的节点为空的时候我们跳出循环
   for curr != nil {
      // 我们先暂时保存下一个节点
      tmp:=curr.Next
      // 当前节点的下一个节点就是前一个节点
      curr.Next = prev
      // 修改后我们就把前一个接地那切换为当前节点
      prev = curr
      // 然后当前节点就是下一个基点
      curr = tmp
   }
   return prev
}
```

java的实现代码如下

```java
public ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode current = head;
    while (current!=null){
        ListNode tmp = current.next;
        current.next = prev;
        prev = current;
        current = tmp;
    }
    return prev;
}
```

## 2.LRU缓存机制

[146. LRU 缓存机制 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/lru-cache/)

![image-20210415160739668](https://img.xiaoyou66.com/2021/04/15/54901780c3bc0.png)

这题目算是比较复杂的了，先简单解释一怎么实现。我们维护一个链表和一个map，map用于判断数据是否存在，然后list用于表示使用的情况，如果是使用过就会放在最前面，然后我们每次淘汰时，都会淘汰最末尾的元素。

注意，这东西得多写几遍。。。我第一次写。错了8次。。。还是看了代码的情况下，这里有好多细节可以扣

```go
type entry struct {
   key, value int
}

type LRUCache struct {
   cap   int
   cache map[int]*list.Element
   lst   *list.List
}

// 构造缓存
func Constructor(capacity int) LRUCache {
   return LRUCache{capacity, map[int]*list.Element{}, list.New()}
}

// 获取值
func (c *LRUCache) Get(key int) int {
   // 获取值，如果不为空，那么就返回-1
   e := c.cache[key]
   if e == nil {
      return -1
   }
   // 把当前值移动到头部
   c.lst.MoveToFront(e) // 刷新缓存使用时间
   return e.Value.(entry).value
}

// 设置值
func (c *LRUCache) Put(key, value int) {
   // 判断缓存中是否存在
   if e := c.cache[key]; e != nil {
      // 存在就更新
      e.Value = entry{key, value}
      c.lst.MoveToFront(e) // 刷新缓存使用时间
      return
   }
   // 不存在我们就放一个新的
   c.cache[key] = c.lst.PushFront(entry{key, value})
   // 哦按的是否超过大小，如果超过，那么就删除
   if len(c.cache) > c.cap {
      delete(c.cache, c.lst.Remove(c.lst.Back()).(entry).key)
   }
}
```

