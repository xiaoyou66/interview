---
title: 其他
date: 2021-03-23 22:38:16
permalink: /pages/f77480/
categories:
  - 基础学科
  - 操作系统
tags:
  - 
---
## 操作系统相关

### 冯诺伊曼体系

该思想约定了用二进制进行计算和存储，还定义计算机基本结构为 5 个部分，分别是**中央处理器（CPU）、内存、输入设备、输出设备、总线**。

## 文件相关

### 文件组成

以Linux系统为例，在Linux系统中一切皆文件，Linux文件系统会为每个文件分配`索引节点 inode`跟`目录项directory entry`来记录文件内容跟目录层次结构。

### 文件类型

划分文件类型的目的是为了更好地管理文件，按照不同的分类，可以将文件类型进行不同的划分

- 按照用途划分
  - 系统文件
  - 用户文件
  - 库文件
- 按照文件中数据的形式划分
  - 源文件
  - 目标文件
  - 可执行文件
- 按照存取控制权限划分
  - 只执行文件
  - 只读文件
  - 读写文件
- 按照组织形式和处理方式划分
  - 普通文件
  - 二进制文件
  - 特殊文件

[操作系统基础之文件管理 - 简书 (jianshu.com)](https://www.jianshu.com/p/de35926643d3)

## CAP理论

**一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项**。

### 一致性（Consistency）

一致性指“`all nodes see the same data at the same time`”，即所有节点在同一时间的数据完全一致。

一致性是因为多个数据拷贝下并发读写才有的问题，因此理解时一定要注意结合考虑多个数据拷贝下并发读写的场景。

### 可用性（Availability）

可用性指“`Reads and writes always succeed`”，即服务在正常响应时间内一直可用。

好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。可用性通常情况下可用性和分布式数据冗余，负载均衡等有着很大的关联。

### 分区容错性（Partition tolerance）

分区容错性指“`the system continues to operate despite arbitrary message loss or failure of part of the system`”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务。

### CAP权衡

CA without P：如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但其实分区不是你想不想的问题，而是始终会存在，因此CA的系统更多的是允许分区后各子系统依然保持CA。
CP without A：如果不要求A（可用），相当于每个请求都需要在Server之间强一致，而P（分区）会导致同步时间无限延长，如此CP也是可以保证的。很多传统的数据库分布式事务都属于这种模式。
AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。现在众多的NoSQL都属于此类。

对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9，即保证P和A，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。

对于涉及到钱财这样不能有一丝让步的场景，C必须保证。网络发生故障宁可停止服务，这是保证CA，舍弃P。貌似这几年国内银行业发生了不下10起事故，但影响面不大，报道也不多，广大群众知道的少。还有一种是保证CP，舍弃A。例如网络故障事只读不写。

孰优孰略，没有定论，只能根据场景定夺，适合的才是最好的。

参考：

[谈谈分布式系统的CAP理论 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/33999708)

## 系统调用

Linux内核中设置了一组用于实现各种系统功能的子程序，称为系统调用。用户可以通过系统调用命令在自己的应用程序中调用它们。从某种角度来看，系统调用和普通的函数调用非常相似。区别仅仅在于，系统调用由操作系统核心提供，运行于核心态;而普通的函数调用由函数库或用户自己提供，运行于用户态。

随Linux核心还提供了一些C语言函数库，这些库对系统调用进行了一些包装和扩展，因为这些库函数与系统调用的关系非常紧密，所以习惯上把这些函数也称为系统调用。

主要分为以下几大类

- 进程控制

- 文件系统控制
  - 文件读写
  - 文件系统操作
- 系统控制
- 内存管理
- 网络管理
- socket控制
- 用户管理
- 进程间通信
  - 信号
  - 消息
  - 管道
  - 信号量
  - 共享内存

[Linux系统调用详解（实现机制分析）--linux内核剖析（六）_OSKernelLAB-CSDN博客_linux系统调用](https://blog.csdn.net/gatieme/article/details/50779184)

[什么是系统调用?为什么要用系统调用? - 华为云 (huaweicloud.com)](https://www.huaweicloud.com/articles/3aa84d6af3129d6798168a162d5124c8.html)

## Socket编程

[Linux Socket编程（不限Linux） - 吴秦 - 博客园 (cnblogs.com)](https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html)

服务端socket编程参考这个：

[linux下socket编程实现一个服务器连接多个客户端_孔乙己大叔的博客-CSDN博客](https://blog.csdn.net/Ctrl_qun/article/details/52524086)

## 程序编译执行流程

**编译流程**

构建C程序需要4个步骤，分别使用4个工具完成： preprocessor, compiler, assembler, and linker.四步完成后生成一个可执行文件。

1. 第一步，预处理. 这一步处理 头文件、条件编译指令和宏定义。
2. 第二步，编译. 将第一步产生的文件连同其他源文件一起编译成汇编代码。
3. 第三步，汇编。将第二步产生的汇编源码转换为 object file.
4. 第四步，链接. 将第三步产生的一些object file 链接成一个可执行的文件。

**执行流程**

1. 将编译后的程序加载到操作系统的执行内存中。
2. 操作系统把加载到内存中的数据进行人为的分区，大致分为:

- .data区：常量区，存放程序中的所有静态常量，相当于java中的public static 的常量,在C语言中则是通过宏定义(define)声明的常量。
- .code区：方法区，存放funcation编译后的声明和实现的描述(其实也是0101).
- 栈(Stack)空间：程序运行时存放变量的空间，大小由操作系统指定，是一块连续的内存空间，访问速度和效率比Heap要高一些。
- 堆(Heap)空间：存放对象的一块不连续的内存空间，访问、存储效率比栈稍低。

1. 划分好区域并将对应的数据加载到各自分区后，各个内存分区开始配合工作，举例：

参考：

1. [程序的编译与执行过程_bdss58的专栏-CSDN博客_程序编译执行步骤](https://blog.csdn.net/bdss58/article/details/78981212)
2. [4.C语言程序执行的流程 - 简书 (jianshu.com)](https://www.jianshu.com/p/bcf6656149ea)

