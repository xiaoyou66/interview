---
title: 进程和线程
date: 2021-03-20 15:50:06
permalink: /pages/5bfa72/
categories:
  - 基础学科
  - 操作系统
tags:
  - 
---

## 基本概念

### 进程和线程的区别

- 进程：**进程**是系统进行资源分配和调度的一个**独立单位**，是系统中的并发执行的单位
- 线程：**线程**是进程的一个实体，也是  CPU  调度和分派的基本单位，它是比进程更小的能独立运行的基本单位，有时又被称为轻量级进程
- 进程是**资源分配**的最小单位，而线程是 **CPU  调度**的最小单位
- 创建进程或撤销进程，系统都要为之分配或回收资源，操作系统开销远大于创建或撤销线程时的开销
- 不同进程地址空间相互独立，同一进程内的线程共享同一地址空间。一个进程的线程在另一个进程内是不可见的
- 进程间不会相互影响，而一个线程挂掉将可能导致整个进程挂掉

### 进程包括那些东西

①程序。作用：描述进程要完成的功能。
②数据。作用：程序在执行时所需要的数据和工作区。
③ PCB。作用：包含进程的描述信息和控制信息。它是进程存在的唯一标志。 进程控制块

在Linux中，进程在内存中按照如下规则分布

![image.png](https://img.xiaoyou66.com/2021/04/12/ed5895ebd7c44.png)

**程序段(Text)**:  程序代码在内存中的映射，存放函数体的二进制代码。

**初始化过的数据(Data):** 在程序运行初已经对变量进行初始化的数据。

**未初始化过的数据(BSS):** 在程序运行初未对变量进行初始化的数据。

**栈(Stack):** 存储局部、临时变量，函数调用时，存储函数的返回指针，用于控制函数的调用和返回。在程序块开始时自动分配内存,结束时自动释放内存，其操作方式类似于数据结构中的栈。

**堆 (Heap):** 存储动态内存分配,需要程序员手工分配,手工释放.注意它与数据结构中的堆是两回事，分配方式类似于链表。

参考：[Linux - 进程(一) 进程空间_zzbjut-CSDN博客](https://blog.csdn.net/zhangzhebjut/article/details/39060253)

### 多线程的优点

- 更加高效的内存共享。多进程下内存共享不便
- 较轻的上下文切换。因为不用切换地址空间，CR3寄存器和清空TLB

### 多进程的优点

- 各个进程有自己内存空间，所以具有更强的容错性，不至于一个集成crash导致系统崩溃
- 具有更好的多核可伸缩性，因为进程将地址空间，页表等进行了隔离，在多核的系统上可伸缩性更强

### 如何提升多线程的效率

- 尽量使用池化技术，也就是线程池，从而不用频繁的创建，销毁线程
- 减少线程之间的同步和通信
- 通过Huge Page的方式避免产生大量的缺页异常
- 避免需要频繁共享写的数据

### 进程之间的通信方式

- **管道**  管道是单向的，一个输入，另一个可以得到输出
- **消息队列** 在发送数据的时候，按照一个个独立单元(消息体)进行发送
- **共享内存** 通过**shmget**创建一份**共享内存**，并可以通过ipcs命令查看我们创建的共享内存。此时如果一个进程需要访问这段内存，需要将这个内存加载到自己虚拟地址空间的一个位置，让内核给它一个合法地址。使用完毕接触板顶并删除内存对象
- **信号量** 用于保证同一份资源只能有一个进程使用，信号量提供了P（申请资源）V（释放资源）操作
- **信号** 其实就是通知机制，不同的信号有不同的值，我们只需要发送一个信号，然后函数接收并进行处理
- **套接字** 不同进程使用socket进行通信

### 进程调度算法

- **FCFS 先来先服务**  先来的先进行服务
- **SPN 最短进程优先**  就是服务时间最短的先执行
- **SRT 最短剩余时间**  当程序的剩余时间最短的先执行
- **轮转（RR）调度算法** 给每个进程都执行一个时间片，执行完后放到队列尾部，然后我们执行队列头部
- **FB反馈算法** 有多个就绪队列，不同的队列有不同的优先级（越到前面越高），队列就按FCFS执行，然后当被其他进程强占时，会降低至第二队列，直到第n个队列（只有当前面的队列为空，才执行当前队列）

### 进程调度模型

![image-20210304215513880](https://img.xiaoyou66.com/2021/03/23/fcc24707bbf33.png)

1. `阻塞` 一般是当系统执行IO操作时，此时进程进入阻塞状态，等待某个事件的返回。
2. `挂起` 是指进程没有占有物理内存，被写到磁盘上了。这时进程状态是挂起状态。
3. `阻塞挂起` 进程被写入硬盘并等待某个事件的出现。
4. `就绪挂起` 进程被写入硬盘，进入内存可直接进入就绪状态。

### PCB 进程控制块

作用是使一个在多道程序环境下不能独立运行的程序，成为一个能独立运行的基本单位，一个能与其它进程并发执行的进程

#### PCB包含的信息

1. **进程标识符**  用于唯一地标识一个进程，一个进程通常有两种标识符：
   1. `内部进程标识符`：标识各个进程，每个进程都有一个并且唯一的标识符，设置内部标识符主要是为了方便系统使用。
   2. `外部进程标识符`：它由创建者提供，可设置用户标识，以指示拥有该进程的用户。往往是由用户进程在访问该进程时使用。一般为了描述进程的家族关系，还应设置父进程标识及子进程标识。
2. **处理机状态** 由各种寄存器组成。包含许多信息都放在寄存器中，方便程序restart。
   1. 通用寄存器、指令计数器、程序状态字PSW、用户栈指针等信息。
3. **进程调度信息**
   1. 进程状态：指明进程的当前状态，作为进程调度和对换时的依据。
   2. 进程优先级：用于描述进程使用处理机的优先级别的一个整数，优先级高的进程应优先获得处理机
   3. 进程调度所需的其它信息：与所采用的进程调度算法有关，如进程已等待CPU的时间总和、进程已执行的时间总和等。
   4. 事件：指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因。
4. **资源清单**  有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。

#### PCB组织方式

1. 线性方式
2. 索引方式
3. 链接方式

### 用户态和内核态

- 内核态：cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。
- 用户态：只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。

#### 为什么要有用户态和内核态呢？

由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 -- 用户态和内核态。

#### 如何从用户态切换到内核态

- **系统调用** 这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如 fork() 实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如 Linux 的 int 80h 中断。
- **中断** 当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。
- **异常** 当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。

**参考**

1. [用户态和内核态的区别_youngyoungla-CSDN博客_用户态和内核态的区别](https://blog.csdn.net/youngyoungla/article/details/53106671)
2. [Linux 用户态切换到内核态的 3 种方式 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/279354447)

## 常问的面试问题

### 说一下你对并发和并行的理解

- **并发**  一个处理器同时处理多个任务
- **并行**  多个处理器或者是多核的处理器同时处理多个不同的任务

### 同步、异步、阻塞、非阻塞的概念

同步和异步是操作系统的层面，然后阻塞和非阻塞内核层面的操作

**同步** 当一个同步调用发出后，调用者要一直等待返回结果。通知后，才能进行后续的执行。

**异步** 当一个异步过程调用发出后，调用者不能立刻得到返回结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。

**阻塞** 是指调用结果返回前，当前线程会被挂起，即阻塞。

**非阻塞** 是指即使调用结果没返回，也不会阻塞当前线程。

